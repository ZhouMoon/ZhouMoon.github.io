{"meta":{"title":"ZhouMoon","subtitle":"<三人行必有我师>","description":"周海军的博客","author":"ZhouMoon","url":"http://zhoumoon.github.io","root":"/"},"pages":[{"title":"分类","date":"2023-08-01T01:45:09.868Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"categories/index.html","permalink":"http://zhoumoon.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于💥","date":"2024-11-13T08:31:11.489Z","updated":"2024-11-13T08:31:11.489Z","comments":false,"path":"about/index.html","permalink":"http://zhoumoon.github.io/about/index.html","excerpt":"","text":"为什么重回 “Hexo”? E-mail: com_moon@163.com GitHub: https://github.com/ZhouMoon BiliBili: https://space.bilibili.com/40356921 Twitter: https://twitter.com/ZHJTime 版本: 1.0.0 所有: Moon st=>start: 开始 op0=>operation: 印象笔记（开了会员依旧广告轰炸!!!） op1=>operation: OneNote（微软的软件确实不错） op2=>operation: Notion（好,真的好!!! ） op3=>operation: 为知笔记（付费挺好的,但移动端...） op4=>operation: Hexo（逐步迁移...） end=>end: 结束 st->op0->op1->op2->op3->op4->end{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);"},{"title":"Repositories","date":"2023-08-01T01:45:09.978Z","updated":"2023-08-01T01:45:09.978Z","comments":false,"path":"repository/index.html","permalink":"http://zhoumoon.github.io/repository/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-05-05T07:07:51.000Z","updated":"2023-08-01T01:45:09.978Z","comments":false,"path":"tags/index.html","permalink":"http://zhoumoon.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常用命令-OneLineCommand","slug":"other/常用命令-OneLineCommand","date":"2024-11-13T08:12:31.000Z","updated":"2024-11-13T09:19:06.442Z","comments":false,"path":"2024/11/13/other/常用命令-OneLineCommand/","link":"","permalink":"http://zhoumoon.github.io/2024/11/13/other/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-OneLineCommand/","excerpt":"","text":"下载JDK、Arthas并启动 命令1： 下载JDK、Arthas并启动 12curl -O https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_linux-x64_bin.tar.gz &amp;&amp; tar -xzf openjdk-11.0.2_linux-x64_bin.tar.gz &amp;&amp; curl -O https://arthas.aliyun.com/arthas-boot.jar &amp;&amp; $(pwd)/jdk-11.0.2/bin/java -jar arthas-boot.jar 命令2: 下载Arthas并启动 1curl -O https://arthas.aliyun.com/arthas-boot.jar &amp;&amp; $(pwd)/jdk-11.0.2/bin/java -jar arthas-boot.jar K8S K8S命令行自动提示(Red Hat) 1234yum install -y bash-completion ;source /usr/share/bash-completion/bash_completion;source &lt;(kubectl completion bash);echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"Docker开启网络代理","slug":"Linux/Docker开启网络代理","date":"2024-10-08T03:28:06.000Z","updated":"2024-10-08T05:15:14.282Z","comments":false,"path":"2024/10/08/Linux/Docker开启网络代理/","link":"","permalink":"http://zhoumoon.github.io/2024/10/08/Linux/Docker%E5%BC%80%E5%90%AF%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/","excerpt":"","text":"背景 问题描述 安装外部公共仓的开源镜像时，比如sudo docker pull xxx，出现如下报错提示： 123$ sudo docker pull mysqlUsing default tag: latestError response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 报错原因 需要通过配置proxy才能访问外网，docker不能直接依赖基础操作系统环境的proxy，因此需要独立配置属于docker的proxy才能访问外网。 docker proxy配置 配置daemon.json文件 1234sudo mkdir -p /etc/dockersudo cp /etc/docker/daemon.json /etc/docker/daemon.json.baksudo vim /etc/docker/daemon.json 配置docker代理文件 123456789101112131415161718sudo mkdir -p /etc/systemd/system/docker.service.dsudo vim /etc/systemd/system/docker.service.d/http-proxy.conf# 配置内容# [Service]# 代理服务器地址# Environment=&quot;HTTP_PROXY=http://账号:密码@proxy.xxx.com:8080/&quot;# Environment=&quot;HTTPS_PROXY=http://账号:密码@proxy.xxx.com:8080/&quot;# 代理黑名单# Environment=&quot;HTTP_PROXY=http://账号:密码@proxy.xxx.com:8080/&quot;# Environment=&quot;NO_PROXY=decs.com,localhost,127.0.0.1&quot;# 示例[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:19527/&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:19527/&quot;# Environment=&quot;NO_PROXY=decs.com,localhost,127.0.0.1&quot; 重启docker，查看proxy是否配成功 1234sudo systemctl daemon-reloadsudo systemctl restart docker# 查看proxy是否配置成功sudo systemctl show --property=Environment docker","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhoumoon.github.io/tags/Docker/"}]},{"title":"Redis复习","slug":"Java/Redis复习","date":"2023-08-20T03:03:33.000Z","updated":"2023-08-20T03:22:58.868Z","comments":false,"path":"2023/08/20/Java/Redis复习/","link":"","permalink":"http://zhoumoon.github.io/2023/08/20/Java/Redis%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"常见题 Redis为什么快? 基与内存的数据库 单线程避免上下文切换的问题 渐进式ReHash Redis的渐进式Rehash是指在Redis进行哈希表扩容时，将旧哈希表中的键值对逐步迁移到新哈希表的过程。 当Redis需要扩大当前使用的哈希表时，它会创建一个新的更大的哈希表，并将所有键值对从旧哈希表迁移到新哈希表。这个过程可能会耗费一定时间，特别是在处理大量数据时。 为了避免在迁移期间造成阻塞，Redis采用了渐进式Rehash策略。它将整个迁移过程分为多个小步骤，每次只迁移一小部分键值对。在每个小步骤中，Redis会将旧哈希表中一个桶(bucket)中的键值对迁移到新哈希表，并更新相应的指针。 通过这种方式，Redis可以在不阻塞客户端请求的情况下进行Rehash操作。同时，在每个小步骤之间，Redis还会检查是否有新请求要访问旧哈希表中的键值对，并将其转发到新哈希表中。这样可以保证即使在Rehash过程中也能正常处理客户端请求。 渐进式Rehash还具有另外一个好处：它可以避免一次性消耗大量内存。因为在整个迁移过程中，旧哈希表和新哈希表会同时存在，直到所有键值对都迁移完成。这样可以确保在迁移过程中Redis的内存占用量不会突然增加。 需要注意的是，渐进式Rehash是一个渐进的过程，并不是一次性完成的。因此，在Rehash期间，旧哈希表和新哈希表会同时存在，并且可能会占用更多的内存。但是一旦迁移完成，Redis就会释放旧哈希表所占用的内存空间。 总结: Redis的渐进式Rehash策略允许在不阻塞客户端请求的情况下进行哈希表扩容，并逐步将键值对从旧哈希表迁移到新哈希表。这种策略可以保证Redis在处理大量数据时仍能保持高性能，并且避免一次性消耗大量内存。 缓存时间戳 Redis的缓存时戳是通过使用一个称为&quot;时间戳&quot;的数据结构来实现的。时间戳是一个有序集合，其中每个成员都有一个分数（score）与之关联，表示该成员的排序位置。 当需要进行缓存时，Redis会将要缓存的数据作为成员添加到时间戳中，并为其设置一个分数，通常使用当前时间作为分数。这样就可以根据分数对成员进行排序，使得最新添加的成员排在前面。 当需要从缓存中获取数据时，Redis会根据指定的范围从时间戳中获取成员。 例如，可以通过指定范围来获取最新添加的N个成员，或者获取某个时间段内添加的所有成员。 由于时间戳是有序集合，获取最新添加的N个成员只需要取出前N个成员即可，而不需要遍历整个集合。这样就能够快速地获取最新的缓存数据。另外，Redis还提供了一些操作来支持对时间戳进行修剪和删除操作。 例如，可以通过指定范围来删除某个时间段内的所有成员，或者删除旧于某个特定时间点的所有成员。这样可以保持时间戳中只包含最新和有效的缓存数据。 总结 Redis利用有序集合和分数来实现缓存时戳，并通过快速的获取和删除操作来提高缓存的性能。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Manjaro 常用配置及软件","slug":"Linux/Manjaro 常用配置及软件","date":"2023-06-25T02:07:00.000Z","updated":"2024-10-08T03:00:17.819Z","comments":false,"path":"2023/06/25/Linux/Manjaro 常用配置及软件/","link":"","permalink":"http://zhoumoon.github.io/2023/06/25/Linux/Manjaro%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"Manjaro 常用配置及软件 创建用户 12345678910111213141516171819# 切root用户su root sudo useradd -r -m -s /bin/bash moon# 设置密码sudo passwd# -r：建立系统账号# -m：自动建立用户的登入目录# -s：指定用户登入后所使用的shell# 设置sudo# 修改/etc/sudoers 权限chmod +w /etc/sudoersvim /etc/sudoers# 增加moon用户权限moon ALL=(ALL:ALL) ALL# env_reset下添加, 使sudo 执行命令时走代理Defaults env_keep += &quot;http_proxy https_proxy ftp_proxy all_proxy no_proxy&quot;# 还原权限(否则不生效)chmod 440 /etc/sudoers sshd 服务 123456# 查看sshd状态sudo systemctl status sshd# 启动sshdsudo systemctl start sshd# 开机启动sshdsudo systemctl enable sshd ssh 登录 GitHub文档 1234567891011# .ssh文件夹懒人命令mkdir .ssh; cd .ssh; touch authorized_keys; touch id_ed25519; touch id_ed25519.pub; cd ~;# 客户端生成密钥ssh-keygen -t ed25519 -C &quot;邮箱地址&quot;# 将公钥写入远程机器中的 authorized_keys 文件中# 认证相关-选择执行...# 设置权限chmod 700 ~/.ssh; chmod 600 ~/.ssh/*; PacMan换源, 选择快的就行 1sudo pacman-mirrors -c China -i -m rank 添加ArchLinuxCN源 123456789101112131415161718192021# 修改pacman.conf配置文件，添加archlinux源sudo vi /etc/pacman.conf # pacman.conf文件末尾添加两行[archlinuxcn]SigLevel = Optional TrustedOnly# (下面得源任选一个)# 官方源Server = http://repo.archlinuxcn.org/$arch# 163源#Server = http://mirrors.163.com/archlinux-cn/$arch# 中科大#Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch# 阿里#Server = https://mirrors.aliyun.com/archlinuxcn/$arch# 更新源# 安装好之后更新源并添加钥匙环sudo pacman -Sy sudo pacman -S archlinuxcn-keyring 使用yay和AUR 因为 pacman 包管理器本身并不直接支持 AUR，所以我们要装个 AUR helper，打开通往快乐的大门。 Manjaro 自带的 pamac 图形化包管理器在设置中即可开启 AUR 支持。命令行下我选用了 yay，可以直接从官方 community 仓库中安装： 12345678910# 后面那个是编译包时需要的一些工具，不然会报错缺少 fakeroot 之类的sudo pacman -S yay base-devel# 设置 AUR 官方镜像源, 可以是国内的源(!!!清华源不可用,停止代理了!!!)yay --aururl &quot;https://aur.archlinux.org&quot; --save# 开启 pacman 和 yay 的彩色输出sudo sed -i &quot;s/#Color/Color/g&quot; /etc/pacman.conf# 加速 AUR 包构建# sudo sed -i &quot;s/PKGEXT=&#x27;.pkg.tar.xz&#x27;/PKGEXT=&#x27;.pkg.tar&#x27;/g&quot; /etc/makepkg.conf# 默认情况下 makepkg 构建 AUR 包时会启用压缩，构建完了安装又要再解压一次，# 如果只是自己机器上使用的话，实在是没必要（而且大软件包压缩很慢）。 执行一次更新 12345# 查看信息,是否是自己的配置yay -P -g # 同步包数据库并升级所有软件包yay -Syu 常用Pacman &amp; yay基本操作 12345678910111213141516sudo pacman -S package_name # 已知软件包完整名称，安装软件sudo pacman package_name_str # 软件名不完整名称，在包管理库中检索可能的软件包sudo pacman -S extra/package_name # 安装不同仓库中的版本sudo pacman -Syu # 升级整个系统，`y` 是更新数据库，`yy` 是强制更新，`u` 是升级软件sudo pacman -Ss string # 在包数据库中查询软件sudo pacman -Si package_name # 显示软件的详细信息sudo pacman -Sc # 清除软件缓存，即 /var/cache/pacman/pkg 目录下的文件sudo pacman -R package_name # 删除单个软件sudo pacman -Rs package_name # 删除指定软件及其没有被其他已安装软件使用的依赖关系sudo pacman -Qs string # 查询已安装的软件包sudo pacman -Qi package_name # 查询本地安装包的详细信息sudo pacman -Ql package_name # 获取已安装软件所包含的文件的列表sudo pacman -U package.tar.zx # 从本地文件安装sudo pactree package_name # 显示软件的依赖树yay -Yc # 卸载所有无用的依赖，类似 apt autoremove Clash默认系统代理 管理页面 12345678# 只针对当前临时环境变量生效, 临时用可以# 设置代理export &#123;https_proxy=http,http_proxy=http,all_proxy=socks5&#125;&quot;://127.0.0.1:19527&quot;# 查看代理env | grep -i proxy# 清除代理unset http_proxyunset https_proxy 字体 中文字体：Source Hans Sans/Serif yay -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts Nerd字体下载 AUR LazyVim 可能会用到的字体Droid Sans Mono for Powerline Nerd Font Complete 字体目录 /usr/share/fonts 建立字体缓存信息 sudo fc-cache -fv 常用软件 &amp; 命令 1yay -S git extra/jdk8-openjdk maven lazygit zsh tmux neovim tree ranger fzf make python fd ripgrep nodejs wireguard-tools z.lua 安装 12345678910111213141516171819202122cd ~/downloadgit clone https://github.com/skywind3000/z.lua.git# 可用后面dotfiles 中的zsh 配置忽略此步eval &quot;$(lua /home/moon/download/z.lua/z.lua --init zsh)&quot;# 克隆配置 git clone https://github.com/ZhouMoon/dotfiles# rcm 安装 AUR # rcm aur地址# https://aur.archlinux.org/packages/rcmgit clone https://aur.archlinux.org/rcm.git# 进入rcm目录# 下面的三个选项分别是# (i) 在编译完成后安装,# (s) 安装编译时需要的依赖关系,# (r) 在安装完成后删除只在编译时需要的软件包# 关于makepkg的更多帮助,可以查看手册页(man makepkg)makepkg -rsi# 安装 zsh 插件# source .zshrc LazyVim 安装 frp 远程工具安装 下载: frp 软件下载 配置: frp ssh 示例 关于 时不时重装懒的备份了, 持续更新 更新日志: 2023-08-04","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"dotfiles配置同步工具RCM使用","slug":"Linux/dotfiles配置同步工具RCM使用","date":"2022-12-15T13:45:23.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/12/15/Linux/dotfiles配置同步工具RCM使用/","link":"","permalink":"http://zhoumoon.github.io/2022/12/15/Linux/dotfiles%E9%85%8D%E7%BD%AE%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7RCM%E4%BD%BF%E7%94%A8/","excerpt":"","text":"RCM 解决配置文件同步问题，轻松实现多设备配置一键同步 官网 安装 RCM GitHub Gitee 例 Ubuntu 1sudo apt install rcm 常用命令 lsrc 列出当前所有通过 rcm 管理的 dotfile ，以及其对应的符号链接位置 lsrc [-FhqVv] [-B HOSTNAME] [-d DIR] [-I EXCL_PAT] [-S EXCL_PAT] [-s EXCL_PAT] [-t TAG] [-U EXCL_PAT] [-u EXCL_PAT] [-x EXCL_PAT] [files ...] mkrc 将指定的 dotfile 移动至集中存储目录(默认 ~/.dotfiles)，并在原下创建相应的软链接 mkrc [-ChoqSsVvUu] [-t TAG] [-d DIR] [-B HOSTNAME] files ... rcup 更新或创建由 rcm 管理的 dotfile 的软链接 rcup [-CfhiKkqVv] [-B HOSTNAME] [-d DIR] [-g] [-I EXCL_PAT] [-S EXCL_PAT] [-s EXCL_PAT] [-t TAG] [-U EXCL_PAT] [-u EXCL_PAT] [-x EXCL_PAT] [files ...] rcdn 删除通过 rcm 创建的 dotfile 的软链接 rcdn [-hKkqVv] [-B HOSTNAME] [-d DIR] [-I EXCL_PAT] [-S EXCL_PAT] [-s EXCL_PAT] [-t TAG] [-U EXCL_PAT] [-u EXCL_PAT] [-x EXCL_PAT] [files ...] 命令参数含义 -B HOSTNAME: 指定特定主机的目录,而不是使用计算机的主机名对其进行操作。 -C: 复制文件而不是创建软链接。 -d DIR: 指定 dotfiles 目录，可以指定多个。 -F: 在文件旁显示指示符号，@ (文件软链接) ，$ (目录软链接)，x(副本文件)。更多详细信息参考 rcrc 中的 COPY_ALWAYS 和 SYMLINK_DIRS 。 -f: 如果rc文件已经存在于配置目录中，但与 dotfiles 目录中的文件不匹配，删除rc文件，然后创建软链接。 -g: 仅显示 rcup 命令脚本的执行过程，不会修改文件系统上的任何内容。 -h: 显示用法说明 -I EXCL_PAT: 指定不被 -x 排除的文件。 该项在 -x 选项之后应用,使用与 -x 相同的语法格式。可能需要用引号使其不被 Shell 忽略。更多详细信息参考 EXCLUDE PATTERN。 -i: 如果rc文件已经存在于配置目录中，但是与dotfiles目录中的文件不匹配，提示如何处理它。这是默认选项。 -K: 跳过 pre-hooks 和 post-hooks -k: 运行 pre-hooks 和 post-hooks , 这是默认选项。 -o: 将 dotfiles 安装到主机特定的目录中。 -q: 减少详细信息。更多详细信息参考 DIRECTORY LAYOUT。 -S EXCL_PAT: 指定以软链接形式创建的目录。此选项可重复使用，需要用引号使其不被 Shell 忽略。更多详细信息参考 EXCLUDE PATTERN。 -s EXCL_PAT: 指定递归创建的目录而不是软链接式的目录。与 -S 选项相反，可用于撤消它或 rcrc 中的 SYMLINK_DIRS 设置。 此选项可重复使用，需要用引号使其不被 Shell 忽略。更多详细信息参考 EXCLUDE PATTERN。 -t TAG: 指定标签 -U EXCLUDE: 指定不创建软链接和以点 (.) 开头命名的rc文件或目录。此选项可重复使用，需要用引号使其不被 Shell 忽略。更多详细信息参考 EXCLUDE PATTERN。 -u EXCL_PAT: 指定必须使用点 (.) 开头命名的 rc 文件或目录。 与 -U 选项相反，可用于撤消它或 rcrc 中 UNDOTTED 设置。 此选项可重复使用，需要用引号使其不被 Shell 忽略。更多详细信息参考 EXCLUDE PATTERN。 -V: 显示版本号。 -v: 添加详细信息。 可以重复此操作以获取更多的详细信息。 -x EXCL_PAT: 指定排除的文件。此选项可重复使用，需要用引号使其不被 Shell 忽略。更多详细信息参考 EXCLUDE PATTERN。 files ...: 指定的文件列表。 配置 ~/.rcrc 可以使用主目录中的 .rcrc 文件配置rcm dotfile 管理器。 可通过设置 RCRC 环境变量来更改此位置。 支持以下变量: COPY_ALWAYS: 复制列表中的glob相匹配的文件，而非使用软链接。 DOTFILES_DIRS: dotfile 的源目录。列表中的第一个将被 mkrc 用于创建 dotfile 目录，默认值为: ~/.dotfiles 。 EXCLUDES: 排除列表。 HOSTNAME: 计算机的主机名。 通常通过 hostname 命令获得，但此命令并非标准的，获取的主机名或许会有差异，因此使用 HOSTNAME 变量强制使用已知的主机名。 TAGS: 默认标签表。 SYMLINK_DIRS: 列表中目录是软链接，而不是源文件。 UNDOTTED: 列表中的文件是软链接且不用点 (.) 开头命名。如果是 SYMLINK_DIRS 中含有的目录，则该目录将为软链接且不用点 (.) 开头命名。 .rcrc 样例: 123456789COPY_ALWAYS=&quot;ssh/id_* weechat/* netrc&quot;COPY_ALWAYS=&quot;*&quot;DOTFILES_DIRS=&quot;/home/mike/.dotfiles /usr/share/dotfiles&quot;EXCLUDES=&quot;irbrc *:*emacs* dotfiles:python*&quot;HOSTNAME=&quot;ubutu-22&quot;TAGS=&quot;freebsd development email git laptop gmail notmuch&quot;SYMLINK_DIRS=&quot;zprezto texmf&quot;UNDOTTED=&quot;texmf&quot; EXCLUDE PATTERN (排除列表) 使用冒号 (:) 分隔 dotfile 目录和 glob (由普通字符、通配字符组成的字符串，用于匹配文件路径) 。可选择带 dotfile 目录，如果省略则默认为 * ，代表从所有 dotfile 目录匹配。 glob 是相对于 dotfile 目录的相对路径。 例如，要忽略 Thoughtbot-dotfiles 目录中所有与 emacs 相关的项目，使用： thoughtbot-dotfiles:*emacs* 要忽略所有 bash_profile 文件使用： *:bash_profile 或者简写为: bash_profile 注意,通常通过 hostname 命令获得主机名，但此命令并非标准的，获取的主机名或许会有差异，在macOS上，主机名是不可预测的，甚至可能在 DHCP 握手被更改,强烈建议在 rcrc 中,因此使用 HOSTNAME 变量强制使用已知的主机名。 DIRECTORY LAYOUT (目录布局) dotfiles 目录下的任何非点 (.) 开头的、非元文件或目录都将作为点 (.) 开头的文件安装。 例如，.dotfiles/zshrc 将安装到 ~/.zshrc 。 文件安装为软链接。 目录通过建立目录来安装。-C 选项指定文件通过复制安装而不是软链接。 rcrc 中的 COPY_ALWAYS 可用于列出只能复制的文件。 支持三个元文件: host-specific (特定主机文件), tagged (标记文件), hooks 。 host-specific: 以 host- 前缀加主机名命名的目录，存放特定主机的文件，如，.dotfiles/host-scarlett 包含主机名为 scarlett 的计算机 dotfile 文件，且这些文件将仅安装在主机名为scarlett的计算机上。 tagged: 以 tag- 前缀加标签名命名的目录，存放标记该标签的文件，如，仅在指定使用 git 标签时安装 .dotfiles/tag-git 下的文件。 hooks: 名为hooks的目录，存放 hooks 。 rcup 支持两个hooks：pre-up 和 post-up 。它们存放到预设文件名的文件或目录中：.dotfiles/hooks/pre-up 和 .dotfiles/hooks/post-up ，或 .dotfiles/hooks/pre-up/* 和 .dotfiles/hooks/post-up/* 。 这些文件必须是可执行文件。 它们在每次 rcup 运行时都运行，因此必须是幂等(执行后结果还为本身)的。hooks 按字母顺序排序,一次只执行一次。 如，hooks/pre-up/animals 将在 hooks / pre-up/aquariums 之前运行，hooks/pre-up/4-eyes 将在 hooks/post-up/2-u-nothing-compares 之前运行。 日常使用 12345678910111213141516171819202122232425262728# 创建管理(管理.vimrc配置)mkrc .vimrc # 打标签方式创建管理mkrc -t git xxx# 安装 dotfiles 中的 dotfile 文件rcup# 安装指定标签的 dotfile 文件rcup -t git# 安装指定标签的 dotfile 文件，并显示过程rcup -t git -v# 查询被管理的 dotfile 文件lsrc# 查询指定标签的 dotfile 文件lsrc -t git# 查询指定 dotfiles 中的 dotfile 文件lsrc -d ~/.dotfiles# 取消指定标签的安装，并显示过程rcdn -t git -v 我的配置 https://github.com/ZhouMoon/dotfiles","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"WireGuard安装使用","slug":"Linux/WireGuard安装使用","date":"2022-11-12T15:08:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/11/12/Linux/WireGuard安装使用/","link":"","permalink":"http://zhoumoon.github.io/2022/11/12/Linux/WireGuard%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"有什么用，为什么要用，这个你应该懂! 官网 GitHub 安装脚本Docker(目前在用) 安装、配置、迁移简单，但对系统内核有要求，需要注意!!! 括号及里面的内容只是辅助说明，执行命令时删除 -e WG_DEFAULT_ADDRESS=10.0.8.x 没有特殊需求没必要修改 123456789101112131415161718docker run -d \\ --name=wg-easy \\ -e WG_HOST=123.123.123.123 (🚨这里输入服务器的公网IP) \\ -e PASSWORD=passwd123 (🚨这里输入你的密码) \\ -e WG_DEFAULT_ADDRESS=10.0.8.x （🚨默认IP地址）\\ -e WG_DEFAULT_DNS=114.114.114.114 （🚨默认DNS）\\ -e WG_ALLOWED_IPS=10.0.8.0/24 （🚨允许连接的IP段）\\ -e WG_PERSISTENT_KEEPALIVE=25 （🚨重连间隔）\\ -v ~/.wg-easy:/etc/wireguard \\ -p 51820:51820/udp \\ -p 51821:51821/tcp \\ --cap-add=NET_ADMIN \\ --cap-add=SYS_MODULE \\ --sysctl=&quot;net.ipv4.conf.all.src_valid_mark=1&quot; \\ --sysctl=&quot;net.ipv4.ip_forward=1&quot; \\ --restart unless-stopped \\ weejewel/wg-easy 开启云服务器端口 TCP/UDP(51820/51821) 配置文件路径，服务器迁移时备份 ~/.wg-easy Web管理页面 IP:51821 可能会用到的命令 12345678910# 查看网卡ip addr# 以下命令不属于本文档# 启动wg0wg-quick up wg0#关闭wg0wg-quick down wg0#查看状态wg-quick status wg0 相关链接 司波图-基于Wireguard技术的虚拟个人网络搭建(B站有视频详细说明) WireGuard Easy","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"Scoop安装使用记录","slug":"Windows/Scoop安装使用记录","date":"2022-09-02T03:22:30.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/09/02/Windows/Scoop安装使用记录/","link":"","permalink":"http://zhoumoon.github.io/2022/09/02/Windows/Scoop%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"环境 1234# Windows 10 专业版 # 确保是powershell 5（及以上）# 查看当前版本 $PSVersionTable.PSVersion 安装 12345678910111213# 将执行权限改为本地无需签名Set-ExecutionPolicy RemoteSigned -scope CurrentUser# 设置 scoop 安装路径为 D:\\scoop$env:SCOOP=&#x27;D:\\Scoop&#x27;[environment]::setEnvironmentVariable(&#x27;SCOOP&#x27;,$env:SCOOP,&#x27;User&#x27;)# 全局安装路径修改(可以不执行)$env:SCOOP_GLOBAL=&#x27;D:\\ScoopGlobalApps&#x27;[environment]::setEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;,$env:SCOOP_GLOBAL,&#x27;Machine&#x27;)# 下载并执行脚本iwr -useb get.scoop.sh | iex 迁移 安装Scoop 将原Scoop文件内容复制到目标Scoop目录 重新设定图标: scoop reset * 懒人命令 12# 更新、清理缓存、清理历史版本scoop update * ; scoop cache rm *;scoop cleanup *; F&amp;A 1234567891011如果使用&quot;科学上网&quot;，需要通过如下命令关闭 aria2scoop config aria2-enabled false# aria2 在 Scoop 中默认开启scoop config aria2-enabled true# 关于以下参数的作用，详见aria2的相关资料scoop config aria2-retry-wait 4scoop config aria2-split 16scoop config aria2-max-connection-per-server 16scoop config aria2-min-split-size 4M","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://zhoumoon.github.io/tags/Windows/"}]},{"title":"AidLux使用记录","slug":"Linux/AidLux使用记录","date":"2022-05-18T09:00:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/05/18/Linux/AidLux使用记录/","link":"","permalink":"http://zhoumoon.github.io/2022/05/18/Linux/AidLux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"AdiLux官方 SSH连接 编辑配置文件 vi /etc/ssh/ssh_config 启动 /etc/init.d/ssh start 客户端连接 ssh root@ip -p9022 密码: aidlux AidLux同步系统时间 12cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtimedate 软件安装 需要注意安装软件与cpu架构相同, jdk maven 可以通过包管理直接安装","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"IDEA无法启动问题","slug":"IDE/IDEA无法启动问题","date":"2022-05-18T01:43:00.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2022/05/18/IDE/IDEA无法启动问题/","link":"","permalink":"http://zhoumoon.github.io/2022/05/18/IDE/IDEA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"启动报错 123Internal error. Please refer to http://jb.gg/ide/critical-startup-errors.......... 解决 1netsh winsock reset 总结 重装 (没用) 删插件 (没用) 删配置 (没用) 重启 (有用) 问题出现 出现在前一天正常使用, 电脑休眠一夜后","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://zhoumoon.github.io/tags/IDE/"}]},{"title":"Windows杀死java进程","slug":"Windows/Windows杀死java进程","date":"2022-05-14T07:38:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/05/14/Windows/Windows杀死java进程/","link":"","permalink":"http://zhoumoon.github.io/2022/05/14/Windows/Windows%E6%9D%80%E6%AD%BBjava%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"查询端口 windows 系统查询8080端口的进程 netstat -ano | findstr 8080 查询运行的程序 tasklist或jps 命令查看当前系统中的进程列表 如查看chrome 进程: tasklist | findstr chrome 杀死进程 通过name: taskkill /im nginx.exe /f 通过pid: taskkill /pid 8568 /f 命令详解 TASKLIST 123456789101112131415161718192021222324252627282930313233343536373839404142434445TASKLIST [/S system [/U username [/P [password]]]] [/M [module] | /SVC | /V] [/FI filter] [/FO format] [/NH]描述: 该工具显示在本地或远程机器上当前运行的进程列表。 参数列表: /S system 指定连接到的远程系统。 /U [domain\\]user 指定应该在哪个用户上下文执行这个命令。 /P [password] 为提供的用户上下文指定密码。如果省略，则提示输入。 /M [module] 列出当前使用所给 exe/dll 名称的所有任务。 如果没有指定模块名称，显示所有加载的模块。 /SVC 显示每个进程中主持的服务。 /V 显示详述任务信息。 /FI filter 显示一系列符合筛选器指定的标准的任务。 /FO format 指定输出格式。 有效值: &quot;TABLE&quot;、&quot;LIST&quot;、&quot;CSV&quot;。 /NH 指定列标题不应该在输出中显示。 只对 &quot;TABLE&quot; 和 &quot;CSV&quot; 格式有效。 /? 显示帮助消息。筛选器: 筛选器名 有效操作符 有效值 ----------- --------------- -------------------------- STATUS eq, ne RUNNING |NOT RESPONDING | UNKNOWN IMAGENAME eq, ne 映像名称 PID eq, ne, gt, lt, ge, le PID 值 SESSION eq, ne, gt, lt, ge, le 会话编号 SESSIONNAME eq, ne 会话名 CPUTIME eq, ne, gt, lt, ge, le CPU 时间，格式为hh:mm:ss。hh - 时，mm - 分，ss - 秒 MEMUSAGE eq, ne, gt, lt, ge, le 内存使用量，单位为 KB USERNAME eq, ne 用户名，格式为 [domain\\]user SERVICES eq, ne 服务名称 WINDOWTITLE eq, ne 窗口标题 MODULES eq, ne DLL 名称说明: 当查询远程机器时，不支持 &quot;WINDOWTITLE&quot; 和 &quot;STATUS&quot; 筛选器。示例: TASKLIST TASKLIST /M TASKLIST /V /FO CSV TASKLIST /SVC /FO LIST TASKLIST /M wbem* TASKLIST /S system /FO LIST TASKLIST /S system /U domain\\username /FO CSV /NH TASKLIST /S system /U username /P password /FO TABLE /NH TASKLIST /FI &quot;USERNAME ne NT AUTHORITY\\SYSTEM&quot; /FI &quot;STATUS eq running&quot; TASKKILL 12345678910111213141516171819202122232425262728293031323334353637383940414243444546TASKKILL [/S system [/U username [/P [password]]]] &#123; [/FI filter] [/PID processid | /IM imagename] &#125; [/T] [/F]描述: 使用该工具按照进程 ID (PID) 或映像名称终止任务。参数列表: /S system 指定要连接的远程系统。 /U [domain\\]user 指定应该在哪个用户上下文执行这个命令。 /P [password] 为提供的用户上下文指定密码。如果忽略，提示输入。 /FI filter 应用筛选器以选择一组任务。允许使用 &quot;*&quot;。例如，映像名称 eq acme* /PID processid 指定要终止的进程的 PID。使用 TaskList 取得 PID。 /IM imagename 指定要终止的进程的映像名称。通配符 &#x27;*&#x27;可用来 指定所有任务或映像名称。 /T 终止指定的进程和由它启用的子进程。 /F 指定强制终止进程。 /? 显示帮助消息。筛选器: 筛选器名 有效运算符 有效值 ----------- --------------- ------------------------- STATUS eq, ne RUNNING | NOT RESPONDING | UNKNOWN IMAGENAME eq, ne 映像名称 PID eq, ne, gt, lt, ge, le PID 值 SESSION eq, ne, gt, lt, ge, le 会话编号。 CPUTIME eq, ne, gt, lt, ge, le CPU 时间，格式为 hh:mm:ss。 hh - 时， mm - 分，ss - 秒 MEMUSAGE eq, ne, gt, lt, ge, le 内存使用量，单位为 KB USERNAME eq, ne 用户名，格式为 [domain\\]user MODULES eq, ne DLL 名称 SERVICES eq, ne 服务名称 WINDOWTITLE eq, ne 窗口标题 说明 ---- 1) 只有在应用筛选器的情况下，/IM 切换才能使用通配符 &#x27;*&#x27;。 2) 远程进程总是要强行 (/F) 终止。 3) 当指定远程机器时，不支持 &quot;WINDOWTITLE&quot; 和 &quot;STATUS&quot; 筛选器。例如: TASKKILL /IM notepad.exe TASKKILL /PID 1230 /PID 1241 /PID 1253 /T TASKKILL /F /IM cmd.exe /T TASKKILL /F /FI &quot;PID ge 1000&quot; /FI &quot;WINDOWTITLE ne untitle*&quot; TASKKILL /F /FI &quot;USERNAME eq NT AUTHORITY\\SYSTEM&quot; /IM notepad.exe TASKKILL /S system /U domain\\username /FI &quot;USERNAME ne NT*&quot; /IM * TASKKILL /S system /U username /P password /FI &quot;IMAGENAME eq note*&quot;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"},{"name":"Windows","slug":"Windows","permalink":"http://zhoumoon.github.io/tags/Windows/"}]},{"title":"Windows运行java-jar启动报错","slug":"Windows/Windows运行java-jar启动报错","date":"2022-05-14T07:22:21.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/05/14/Windows/Windows运行java-jar启动报错/","link":"","permalink":"http://zhoumoon.github.io/2022/05/14/Windows/Windows%E8%BF%90%E8%A1%8Cjava-jar%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/","excerpt":"","text":"问题 在IDEA 、 Linux 运行没有问题 在Windows 环境运行java -Xms128m -Xmx256m -jar test.jar --spring.profiles.active=local 居然报错 12345......省略15:21:23.678 [main] [,] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@148080bb, started on Sat May 14 15:21:10 CST 202215:21:23.680 [main] [,] ERROR org.springframework.boot.SpringApplication - Application run failedorg.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat......省略 解决 最终命令:nohup java -Dfile.encoding=utf-8 -Xms128m -Xmx256m -jar test.jar --spring.profiles.active=local1 &amp; 其实就是增加了编码 -Dfile.encoding=utf-8 相关连接 Windows杀死java进程","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"},{"name":"Windows","slug":"Windows","permalink":"http://zhoumoon.github.io/tags/Windows/"}]},{"title":"Ubuntu 常用配置及软件","slug":"Linux/Ubuntu 常用配置及软件","date":"2022-05-04T14:02:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/05/04/Linux/Ubuntu 常用配置及软件/","link":"","permalink":"http://zhoumoon.github.io/2022/05/04/Linux/Ubuntu%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"Ubuntu 常用配置及软件 创建用户 12345678910111213141516171819# 切root用户su root sudo useradd -r -m -s /bin/bash moon# 设置密码sudo passwd# -r：建立系统账号# -m：自动建立用户的登入目录# -s：指定用户登入后所使用的shell# 设置sudo# 修改/etc/sudoers 权限chmod +w /etc/sudoersvim /etc/sudoers# 增加moon用户权限moon ALL=(ALL:ALL) ALL# env_reset下添加, 使sudo 执行命令时走代理Defaults env_keep += &quot;http_proxy https_proxy ftp_proxy all_proxy no_proxy&quot;# 还原权限(否则不生效)chmod 440 /etc/sudoers 时间校准 12sudo apt-get install ntpntpdate cn.pool.ntp.org Clash默认系统代理 管理页面 1234567891011# 设置代理export https_proxy=http://127.0.0.1:19527 http_proxy=http://127.0.0.1:19527 all_proxy=socks5://127.0.0.1:19527# 查看代理env |grep -i proxy# 清除代理unset http_proxyunset https_proxy# 通过图形界面设置的代理清除sudo vi /etc/apt/apt.confsudo vi ~/.bashrcsudo vi /etc/enviroment 软件源配置 编辑文件sudo vi /etc/apt/sources.list 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 清华源 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# 中科大源# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse # 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverseo# 阿里源deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 常用软件 sudo apt install git zsh tmux neovim tree ranger fzf 字体安装 Nerd字体下载 字体目录: /usr/share/fonts 建立字体缓存信息 sudo fc-cache -fv 配置终端 个性化配置 克隆配置 git clone https://github.com/ZhouMoon/dotfiles ssh服务 服务安装 sudo apt-get install openssh-server 创建authorized_keys sudo touch ~/.ssh/authorized_keys 客户端生成密钥 ssh-keygen 将公钥写入远程机器中的 authorized_keys 文件中 JDK 安装 JDK安装 Maven 安装 sudo apt install maven frp 远程工具安装 下载: frp 软件下载 配置: frp ssh 示例 可能出现的问题 nvim 启动后报错 尝试安装g++ gcc 尝试重新安装插件 关于 时不时重装懒的备份了, 直接重新下载, 持续更新","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"IDEA 中VIM配置文件ideavimrc文件无法打开问题","slug":"IDE/IDEA 中VIM配置文件ideavimrc文件无法打开问题","date":"2022-03-11T16:33:00.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2022/03/12/IDE/IDEA 中VIM配置文件ideavimrc文件无法打开问题/","link":"","permalink":"http://zhoumoon.github.io/2022/03/12/IDE/IDEA%20%E4%B8%ADVIM%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6ideavimrc%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E9%97%AE%E9%A2%98/","excerpt":"","text":"IDEA 中VIM配置文件ideavimrc文件无法打开问题 今天编辑 .ideavimrc 文件中突然在idea中没有高亮显示,当尝试关闭文件重新打时突然无法打开了!! IDEA 中无法打开 配置依旧生效 解决方法 修改IDEA配置 打开设置: Settings -&gt; Editor -&gt; File Type 新增文件类型: File name patterns -&gt; 添加 *.ideavimrc 文件类型 保存收工 问题原因猜想 .ideavimrc文件在IDE看来是一个没有命名文件而已,所以无法打开 可能是一个未知bug , 因为在DataGrip(版本稍高) 中可以正常打开","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://zhoumoon.github.io/tags/IDE/"}]},{"title":"第四课 反常识!","slug":"MoneyManagement/第四课-反常识!","date":"2022-01-21T15:58:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/01/21/MoneyManagement/第四课-反常识!/","link":"","permalink":"http://zhoumoon.github.io/2022/01/21/MoneyManagement/%E7%AC%AC%E5%9B%9B%E8%AF%BE-%E5%8F%8D%E5%B8%B8%E8%AF%86!/","excerpt":"","text":"第四课 反常识! 股票投资避坑指南 什么是股票 股票（stock）是股份公司所有权的一部分，也是发行的所有权凭证，是股份公司为筹集资金而发行给各个股东作为持股凭证并借以取得股息和红利的一种有价证券。 股票是如何赚钱的 获得股息和红利的权利(核心) 转让权(获得价差收益) 参加股东大会的权利 知情权(财务信息及重大事项) 行使表决权 股票投资避坑指南 跟风从众 掌握好技能有自己的标准 投机预测 不预测价格只关注公司本身 价格暴跌 掌握好技能无惧价格涨跌 提问 【提问】：股票的本质是什么？ 买股票，就是买的企业的一部分，所以只要这家公司在不断盈利，不断成长，那我们投资他就会获得较高的收益 【提问】：选择好公司总共几个步骤？ ①理财的底层逻辑、富人思维 ②股票的海选 ③精选出好公司 ④财务报表分析 ⑤企业分析 ⑥计算好价格 ⑦制定买进标准 ⑧制定持有标准 ⑨制定卖出标准等 【提问】：如果能学会理财技能，你愿意付出多长时间？ 第一，买股票就是买企业 第二，股票的赚钱逻辑是分红+价差 财报分析=判断一个公司的过去 企业分析=判断一个公司的未来 牛市,是投资亏损的重要原因 本杰明·格雷厄姆 当别人贪婪时,你就该恐惧,当别人恐惧时,你就该贪婪 — 沃伦·巴非特","categories":[],"tags":[{"name":"理财","slug":"理财","permalink":"http://zhoumoon.github.io/tags/%E7%90%86%E8%B4%A2/"}]},{"title":"第三课 捡钱的秘籍","slug":"MoneyManagement/第三课-捡钱的秘籍","date":"2022-01-19T11:58:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/01/19/MoneyManagement/第三课-捡钱的秘籍/","link":"","permalink":"http://zhoumoon.github.io/2022/01/19/MoneyManagement/%E7%AC%AC%E4%B8%89%E8%AF%BE-%E6%8D%A1%E9%92%B1%E7%9A%84%E7%A7%98%E7%B1%8D/","excerpt":"","text":"第三课 捡钱的秘籍 可能多赚千元的理财方法 收益率提升8倍+ 货币基金(如: 余额宝) 货币基金是聚集社会闲散资金，由基金管理人运作，基金托管人保管资金的一种开放式基金，专门投向风险小的货币市场工具，区别于其他类型的开放式基金，具有高安全性、高流动性、稳定收益性，具有“准储蓄”的特征。 收益: 2.4% 余额宝 (当前时间: 2022-01-20 0:27 周四) 利用信用卡合理消费, 发了工资以后先把工资放在货币基金上（不使用工资和现金消费） 注意: 购买货币基金的时间范围: 周一 00:00 ~ 周四 14:59 收益较好 每年多赚几千块钱 国债逆回购 债券==借条 不求高收益,但求不浪费 苍蝇腿再小也是肉 只要证券账户有钱,天天做,养成习惯 财商高的体现 收益: 2.5% 左右收益, 周期一天左右 虽然收益不多,但也不必嫌少 注意: 最好在节假日前两天购入 打新债、可转债 打新债:打新债，经济术语，意思是指在债券型基金产品刚发行的时候，发行的价格比较低，这时候投资者申购新发行的债券叫做打新债 收益: 运气好有不错的收益, 200~400 未中不产生任何费用 注意: 中签后及时认缴,超出三次不认缴今后很难再中签 可转债:可转换债券是债券持有人可按照发行时约定的价格将债券转换成公司的普通股票的债券 可转换债券是可转换公司债券的简称，又简称可转债，是一种可以在特定时间、按特定条件转换为普通股票的特殊企业债券。可转换债券兼具债权和股权的特征。 工具 常用理财计算器（微淼财商教育） 开放式基金收益计算器 好买基金对比工具 提问 【提问】：信用卡薅羊毛到底怎么薅呢？是让大家直接把钱刷出来放到货币基金吗？ 发了工资以后先把工资放在货币基金上（不使用工资和现金消费） 利用信用卡的钱用于生活支出,在它的免息期间把钱还上，因为信用卡是先消费，后还款的所以这个方法完全可行 【提问】：国债逆回购什么时候买收益率高？ 目录: 每年多赚几千块钱 : 国债收益 成功的秘诀有3条: 第一, 尽量规避风险,保住本金 第二, 尽量规避风险,保住本金 第二, 坚决牢记第一和第二条 — 沃伦·巴非特","categories":[],"tags":[{"name":"理财","slug":"理财","permalink":"http://zhoumoon.github.io/tags/%E7%90%86%E8%B4%A2/"}]},{"title":"第二课 滚雪球","slug":"MoneyManagement/第二课-滚雪球","date":"2022-01-18T12:13:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/01/18/MoneyManagement/第二课-滚雪球/","link":"","permalink":"http://zhoumoon.github.io/2022/01/18/MoneyManagement/%E7%AC%AC%E4%BA%8C%E8%AF%BE-%E6%BB%9A%E9%9B%AA%E7%90%83/","excerpt":"","text":"第二课: 滚雪球 从一万到100万的理财法则 复利的正向作用 单利: 只有本金算利息简的累加 复利: 利滚利, 纸能对折13次吗? sum=m×(1+e)tsum = m × (1 + e)^tsum=m×(1+e)t sum = 最终收益 m = 本金 e = 收益率 t = 时间 复利的反向作用 通货膨胀: 货币贬值、物价上涨 只要经历在持续发展通货膨胀如影随形 CPI – 居民价格消费指数 风险≠收益 决定风险和收益大小的不是工具,而是理财技能 能力越强,风险越小 投资的灵魂有两部分 投资的灵魂复利 拥有复利的能力 跑赢通胀 每年资产最少增加10% 如何拥有人生的第一个100万 计划财富人生 提问 【提问】以上3个因素本金、时间、收益率，对于我们来说哪个是可以快速改变、也是最关键的因素呢？ 收益率 目录: 复利的正向作用公式 【提问】收益越高，风险就越高，这句话对么？ 不对 低风险≠低收益 高风险≠高收益 种一棵树最好的时间是10年前其次就是现在","categories":[],"tags":[{"name":"理财","slug":"理财","permalink":"http://zhoumoon.github.io/tags/%E7%90%86%E8%B4%A2/"}]},{"title":"第一课 财务体检","slug":"MoneyManagement/第一课-财务体检","date":"2022-01-17T13:53:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2022/01/17/MoneyManagement/第一课-财务体检/","link":"","permalink":"http://zhoumoon.github.io/2022/01/17/MoneyManagement/%E7%AC%AC%E4%B8%80%E8%AF%BE-%E8%B4%A2%E5%8A%A1%E4%BD%93%E6%A3%80/","excerpt":"","text":"第一课: 财务体验 看透人生穷富的关键 什么是理财 凡是涉及到跟钱有关的安排,都是理财 什么是资产 一切可以卖钱的东西都是资产 生钱资产: 是能持续给你带来净现金流入的资产，那比如说你买了一个会持续分红的指数基金，他会定期给你分红，那它就属于生钱资产 耗钱资产: 是指持续能给你带来净现金流出的资产，比如说你买了一辆私家车，每个月都要出油钱保养费，有时候还有维修费等等，这就属于耗钱资产 其他资产: 是既不带来现金流入也不带来现金流出的资产，比如黄金 怎么做可以财务自由 财务自由: 家庭非工资收入 &gt; 生活之出 区分支出 好支出: 会让你越来越富有节省更多钱或带来更多钱 坏支出: 会让你越来越穷由于虚荣心产生的非必要支出 富人的两个秘密 生钱资产占总资产的80%以上 好支出占总支出的80%以上 提问 【提问】第一个问题：理财==投资，这句话对不对？ 记住！理财并不等于投资，投资只是理财的一部分 【提问】学会理￥财后，我们要学会用【三大类型的资产】去分类我们手里的资产，三大资产分别是哪三个？ 目录: 什么是资产 【提问】如果想变富，要多拥有哪种类型的资产？ 生钱资产 + 好支出 人一生能积累多少财富,不取决于能赚多少钱,而取决于如何理财.钱找钱胜过人找人,要懂得让钱为你工作,而不是你为钱工作 — 沃伦·巴非特","categories":[],"tags":[{"name":"理财","slug":"理财","permalink":"http://zhoumoon.github.io/tags/%E7%90%86%E8%B4%A2/"}]},{"title":"线上问题-并发引起的优惠券超发问题","slug":"Work/优惠券分发并发问题记录","date":"2021-12-22T16:33:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/12/23/Work/优惠券分发并发问题记录/","link":"","permalink":"http://zhoumoon.github.io/2021/12/23/Work/%E4%BC%98%E6%83%A0%E5%88%B8%E5%88%86%E5%8F%91%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"问题 线上商品优惠券超发 一个用户限领一张结果发了三张,而且不止一个用户 起因 同事细心发现线上有部分用户优惠券居然超发了,如果没发现可想而知。感谢感谢 开始处理 确认超发数量、快速拉通解决方案 初步定位问题原因: 定时任务跑全量正在生效的优惠券,给未分发到的用户或符合条件的用户进行批量分发操作,造成并发领取问题 解决 大致业务流程: 聚合层定时任务触发开启多线程RPC调用优惠券分发服务(双节点) A方法数据先插入数据库(分发) B方法执行更新操作(领取) 第一版 并发锁 123456789101112131415161718192021222324252627282930public class a&#123; public void A()&#123; // 向数据库插入数据 // 分发优惠券 A.installBatch(list); // 调用B,进行 // 领取优惠券 B.(list); &#125;&#125;public class b&#123; public void B(List&lt;A&gt; list))&#123; // 获取锁 RLock lock = redissonClient.getLock(KEY); try &#123; // 设置时间 lock.lock(2, TimeUnit.SECONDS); // 判断优惠领取数量是否达到上限 // 领取优惠券 update(list); // 创建定时任务 // ...... &#125; catch (Exception e) &#123; log.error(e); &#125;finally &#123; // 释放锁 lock.unlock(); &#125; &#125;&#125; 用以上方式可以顺利加锁(优惠券ID+用户ID做为 redis KEY), 但是在测试中还是会出现并发问题, 未解决 其实锁没有问题 经典开始走偏: 怀疑是A 的事物没提交,导致B 查询有问题 在方法B 开启新事物@Transactional(propagation = Propagation.REQUIRES_NEW) ,结果一张都领不上了,反向解bug属于是 然后想是不是A的事物没提交导致B开新事物也查不到呀, 然后手动提交A的事物还是不行,奇怪了,简直在错误的路上越走越远了… 结论 其实分发优惠券的并发是来自于聚合层多线程调用方法A,且可能同时将调用两个服务, 导致无法保证&quot;判断优惠券领取上限&quot;查询是正确数据, 造成优惠数量判断异常,优惠券超发,只能超不能少那种…唉 第二版 并发锁+优惠券数量原子自增(Redis) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class a&#123; public void A()&#123; // 向数据库插入数据 // 分发优惠券 A.installBatch(list); // 调用B,进行 // 领取优惠券 B.(list); &#125;&#125;public class b&#123; public void B(List&lt;A&gt; list))&#123; // 获取锁 RLock lock = redissonClient.getLock(KEY); try &#123; // 设置时间 lock.lock(2, TimeUnit.SECONDS); // 如果数量为空,设置值 Object numValue = redisService.get(numKey.toString()); // 用户剩余可领取数量 int maxNum = 0; if (Validator.empty(numValue)) &#123; // 优惠券设置限领，判断用户领取数量 // 获取用户优惠券领取数量 maxNum = 可领取数 - 已领取数; // 初始化redis优惠券分发数据 redisService.increment(numKey.toString(), maxNum, TWO_MINUTE); &#125; &#125; else &#123; maxNum = Integer.parseInt(numValue.toString()); &#125; // 判断优惠领取数量是否达到上限 // 领取优惠券 update(list); // 原子自增-1 redisService.increment(numKey.toString(), -1, TWO_MINUTE); // 创建定时任务 // ...... &#125; catch (Exception e) &#123; log.error(e); &#125;finally &#123; // 释放锁 lock.unlock(); &#125; &#125;&#125; 写在最后 对业务和数据敏感度还是不够 比单线程逻辑更复杂排查问题难 为保证最终数据一致性,付出的代价是巨大的","categories":[],"tags":[{"name":"Work","slug":"Work","permalink":"http://zhoumoon.github.io/tags/Work/"}]},{"title":"Git 稀疏检出","slug":"Git/Git稀疏检出","date":"2021-11-09T23:12:22.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2021/11/10/Git/Git稀疏检出/","link":"","permalink":"http://zhoumoon.github.io/2021/11/10/Git/Git%E7%A8%80%E7%96%8F%E6%A3%80%E5%87%BA/","excerpt":"","text":"稀疏检出-使用git检索出仓库里的某一个目录文件，而不是整个仓库的所有文件 具体工作意义是从某一个Git仓库 克隆时，只克隆检测出这个仓库里的某些文件夹内容，而不是跟平常那样把整个仓库的内容都克隆下来 从1.7.0版本开始git提供稀疏检出的功能。所谓稀疏检出就是本地版本库检出时不检出全部，只将指定的文件从本地版本库检出到工作区，而其他未指定的文件则不予检出（即使这些文件存在于工作区，其修改也会被忽略）。 检查Git版本 在命令行中运行如下命令 git --version 比如保证git的版本大于1.7.0，这里以 git version 1.8.3.1作为演示。 创建仓库存放目录 mkdir swoole-src-examples &amp;&amp; cd swoole-src-examples 创建一个目录，这里以swoole-src-example，并且使用cd命令进入到目录中。 初始化仓库 执行初始化仓库的命令 git init 添加远程仓库地址 git remote add origin https://github.com/swoole/swoole-src.git 使用Sparse checkout模式 使用下面的命令允许config中使用Sparse checkout模式。 git config core.sparsecheckout true 配置要检出的目录或文件 将要检出的目录或文件使用文件追加的形式写入到git的配置.git/info/sparse-checkout文件中，允许添加多行。 echo “examples/*” &gt;&gt; .git/info/sparse-checkout 多次添加配置后，通过cat .git/info/sparse-checkout命令查看最终添加的目录或者文件。 从远程将目标目录或文件拉取下来 当仓库还是空白的情况下，首次需要执行下面的命令从远程将配置的目录或者文件拉取到本地。 git pull origin master 对配置增删改后重新获取代码 在对配置文件.git/info/sparse-checkout的内容进行增、删、改操作之后，使用下面的命令重新修正目录和文件。 git checkout","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://zhoumoon.github.io/tags/Git/"}]},{"title":"修改键盘映射 - Deepin Wiki","slug":"Linux/修改键盘映射-deepin_Wiki","date":"2021-11-09T23:12:22.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/11/10/Linux/修改键盘映射-deepin_Wiki/","link":"","permalink":"http://zhoumoon.github.io/2021/11/10/Linux/%E4%BF%AE%E6%94%B9%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84-deepin_Wiki/","excerpt":"","text":"修改键盘映射 - Deepin Wiki 有时候，我们需要对键盘上的一些按键（如Ctrl、Alt）进行映射，以便适应不同用户的需求，这时可以借助 gsettings 命令来调整系统设置。 查看当前键盘映射 查看所有映射 1localectl list-x11-keymap-options 查看与 CapsLock 键有关的映射 1localectl list-x11-keymap-options | grep caps: 修改键盘映射 这里以调整 CapsLock（大写锁定）的映射为例。Vim用户可能希望将CapsLock与Esc键交换，从而能方便地使用含有Esc的组合键。 注意，以下命令会立即生效，无需重启系统。 取消按下 CapsLock 时的 osd 提示框 12gsettings set com.deepin.dde.keybinding.mediakey capslock &#x27;[]&#x27; 交换 CapsLock与Esc键 1gsettings set com.deepin.dde.keyboard layout-options &#x27;[&quot;caps:swapescape&quot;]&#x27; 禁用 CapsLock 键 1gsettings set com.deepin.dde.keyboard layout-options &#x27;[&quot;caps:none&quot;]&#x27; 恢复 CapsLock 键的原先设置 可以单独指定 CapsLock 键的设置为默认值： 123gsettings reset com.deepin.dde.keybinding.mediakey capslockgsettings reset com.deepin.dde.keyboard layout-options 也可以使整个键盘的布局恢复为默认设置： 123gsettings reset-recursively com.deepin.dde.keybinding.mediakeygsettings reset-recursively com.deepin.dde.keyboard 参考资料 How to change capslock and other keymapping in deepin linux","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"查看Linux端口占用，并kill掉相关进程","slug":"Linux/查看Linux端口占用，并kill掉相关进程","date":"2021-11-09T23:12:22.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/11/10/Linux/查看Linux端口占用，并kill掉相关进程/","link":"","permalink":"http://zhoumoon.github.io/2021/11/10/Linux/%E6%9F%A5%E7%9C%8BLinux%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%EF%BC%8C%E5%B9%B6kill%E6%8E%89%E7%9B%B8%E5%85%B3%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"查看Linux端口占用，并kill掉相关进程 lsof 命令 1lsof -i:8080 netstat 命令 12查看占用端口进程的PID：netstat -tunlp|grep 8080 ps 1234ps -ef | grep &#123;programName&#125;kill -9 &#123;PID&#125;# 查看详细内存占用ps aux -u root | grep &#123;programName&#125; pgrep 12pgrep &#123;programName&#125;kill -9 &#123;PID&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"从 Vim 执行 Bash 中的当前行行匹配字符","slug":"vim/Vim执行Bash中的当前行","date":"2021-11-02T07:53:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/11/02/vim/Vim执行Bash中的当前行/","link":"","permalink":"http://zhoumoon.github.io/2021/11/02/vim/Vim%E6%89%A7%E8%A1%8CBash%E4%B8%AD%E7%9A%84%E5%BD%93%E5%89%8D%E8%A1%8C/","excerpt":"","text":"从 Vim 执行 Bash 中的当前行 123.w !bash这里 . (w前的部分)指的是你写的行的范围，. 只是当前行.然后你使用 !bash 将这些行写入 Bash Stack Overflow类似问题","categories":[],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://zhoumoon.github.io/tags/Vim/"}]},{"title":"Windows10_如何获取最高管理员权限","slug":"Windows/Windows10_如何获取最高管理员权限","date":"2021-06-15T14:17:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/06/15/Windows/Windows10_如何获取最高管理员权限/","link":"","permalink":"http://zhoumoon.github.io/2021/06/15/Windows/Windows10_%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9C%80%E9%AB%98%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90/","excerpt":"","text":"Windows10 如何获取最高管理员权限 使用Windows10的时候常常发现我们没有管理员权限，这对我们使用造成了巨大麻烦。今天我来分享一下 win10里面怎么获取最高管理员权限。 （一）Windows10专业版/企业版/教育版方法 1，按下win+R键唤出“运行”窗口，输入gpedit.msc 2，这时打开了组策略编辑器，在左边找到“计算机配置-Windows 设置”，再进入右边“安全设置”，如图。 3，进入“本地策略”，如图。 4，进入“安全选项”，如图。 5，向下滑，找到“用户账户控制：以管理员批准模式运行所有管理员”和“用户账户控制：用于内置管理员账户的管理员批准模式”这两项，如图。 6，分别选中并点击鼠标右键，再点击“属性”，进入配置窗口，将这两项都分别设置为“已禁用”，再点击“确定”，如图。 7，重启电脑，操作完成！","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://zhoumoon.github.io/tags/Windows/"}]},{"title":"添加Windows_terminal到右键菜单","slug":"Windows/添加Windows_terminal到右键菜单","date":"2021-06-15T14:17:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/06/15/Windows/添加Windows_terminal到右键菜单/","link":"","permalink":"http://zhoumoon.github.io/2021/06/15/Windows/%E6%B7%BB%E5%8A%A0Windows_terminal%E5%88%B0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/","excerpt":"","text":"添加Windows terminal到右键菜单 可以采用下面的步骤将Windows terminal添加到鼠标右键菜单方便调用。 创建一个文本文件，将其命名为wt.reg 以文本编辑器打开，输入以下文本内容并保存 12345[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@=&quot;Windows terminal here&quot;&quot;Icon&quot; = &quot;C:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\terminal\\\\wt_32.ico&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@=&quot;C:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; 注意替换文件路径中的用户名（如上面的Administrator，替换为自己的）。 鼠标双击运行文件wt.reg修改注册表项 在任意工作路径下点击鼠标右键，如下图所示可以看到菜单项Windows terminal here，点击可进入Windows terminal。 相同的原理可以将一些常用软件放到右键菜单中进行启动，如下面将Fluent 2020R2及Workbench 2020R2放到右键菜单中。 12345678910111213Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Fluent 2020R2]@=&quot;Open Fluent 2020R2&quot;&quot;Icon&quot; = &quot;D:\\\\Program Files\\\\ANSYS Inc\\\\v202\\\\fluent\\\\ntbin\\\\win64\\\\fluent.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Fluent 2020R2\\command]@=&quot;D:\\\\Program Files\\\\ANSYS Inc\\\\v202\\\\fluent\\\\ntbin\\\\win64\\\\fluent.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Workbench 2020R2]@=&quot;ANSYS Workbench 2020R2&quot;&quot;Icon&quot; = &quot;D:\\\\Program Files\\\\ANSYS Inc\\\\v202\\\\Framework\\\\bin\\\\Win64\\\\RunWB2.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Workbench 2020R2\\command]@=&quot;D:\\\\Program Files\\\\ANSYS Inc\\\\v202\\\\Framework\\\\bin\\\\Win64\\\\RunWB2.exe&quot;","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://zhoumoon.github.io/tags/Windows/"}]},{"title":"Vim 多行匹配字符\"\\_.","slug":"vim/Vim多行匹配字符","date":"2021-06-12T07:53:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/06/12/vim/Vim多行匹配字符/","link":"","permalink":"http://zhoumoon.github.io/2021/06/12/vim/Vim%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6/","excerpt":"","text":"Vim 多行匹配字符&quot;\\_.&quot; vi平时我们使用的匹配字符&quot;.&quot;不能够匹配换行符号，所以我们没法使用它进行跨行匹配。 如有以下数据：我们想查找所有在城市为beijing,年龄为18岁的人。 1234567891011121314151617name: Acity: beijingage: 18name:Bcity:shanghaiage:15name: Ccity: beijingage:18 此时&quot;.&quot;就无能为力，我们需要用 \\_.\\&#123;-&#125;(非贪婪) 1/citi: beijing\\_.*age:18 非贪婪 1/citi: beijing\\_.\\&#123;-&#125;age:18 匹配个数 1:%s/citi: beijing\\_.\\&#123;-&#125;age:18//gn","categories":[],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://zhoumoon.github.io/tags/Vim/"}]},{"title":"Vim 提取删除匹配行的方法","slug":"vim/Vim提取删除匹配行的方法","date":"2021-06-12T04:53:00.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2021/06/12/vim/Vim提取删除匹配行的方法/","link":"","permalink":"http://zhoumoon.github.io/2021/06/12/vim/Vim%E6%8F%90%E5%8F%96%E5%88%A0%E9%99%A4%E5%8C%B9%E9%85%8D%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"Vim 提取删除匹配行的方法 12:g/&#123;pattern&#125;/d &quot;删除匹配行:v/&#123;pattern&#125;/d &quot;保留匹配行","categories":[],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://zhoumoon.github.io/tags/Vim/"}]},{"title":"docker导入导出镜像","slug":"Linux/docker导入导出镜像","date":"2020-08-13T13:15:21.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2020/08/13/Linux/docker导入导出镜像/","link":"","permalink":"http://zhoumoon.github.io/2020/08/13/Linux/docker%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E9%95%9C%E5%83%8F/","excerpt":"","text":"save和export区别： docker save保存的是镜像(image),docker export保存的是容器(container); docker load用来载入镜像包,docker import用来载入容器包,但两者都会恢复为镜像; docker load不能对载入的镜像重命名,而docker import可以为镜像指定新名称。 保存(Save) 123456# 保留原镜像的名称和标签docker save &lt;IMAGE NAME&gt;:&lt;IMAGE TAG&gt; &gt; save.tar# 不保留原镜像的基本信息,加载load后需执行tag命令重命名none镜像docker save &lt;IMAGE ID&gt; &gt; save.tar 示列: 1234docker save elasticsearch:7.1.1 &gt; elasticsearch-7.1.1.tar# 或docker save b0cb1543380d &gt; elasticsearch-7.1.1.tar 加载(Load) 12docker load &lt; save.tar 示列: 12docker load &lt; elasticsearch-7.1.1.tar 导出(Export) 12docker export &lt;CONTAINER ID&gt; &gt; export.tar 示列: 12docker export b0cb1543380d &gt; elasticsearch-7.1.1.tar 导入(Import) 12docker import export.tar &lt;IMAGE NAME&gt;:&lt;IMAGE TAG&gt; 示列: 12docker import elasticsearch-7.1.1.tar elasticsearch:7.1.1 提交(Commit) 使用commit命令可以把一个正在运行的容器变成一个新的镜像。 12docker commit &lt;CONTAINER ID&gt; &lt;IMAGE NAME&gt;:&lt;IMAGE TAG&gt; 示列: 12docker commit b0cb1543380d elasticsearch:latest 问题(None) docker加载新的镜像后repository和tag名称都为none的解决方法 123REPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; b0cb1543380d 2 months ago 847MB 方案 12docker tag &lt;IMAGE ID&gt; &lt;IMAGE NAME&gt;:&lt;IMAGE TAG&gt; 示列: 12docker tag b0cb1543380d elasticsearch:7.1.1 本文转自 https://juejin.cn/post/6844903905881505800，如有侵权，请联系删除。","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhoumoon.github.io/tags/Docker/"}]},{"title":"Docker redis安装_并配置远程连接","slug":"Linux/Docker redis安装_并配置远程连接","date":"2020-08-12T12:12:01.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2020/08/12/Linux/Docker redis安装_并配置远程连接/","link":"","permalink":"http://zhoumoon.github.io/2020/08/12/Linux/Docker%20redis%E5%AE%89%E8%A3%85_%E5%B9%B6%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","excerpt":"","text":"【Docker】redis安装 并配置远程连接 获取 redis 镜像 123docker search redisdocker pull redis:latestdocker images 创建容器 创建宿主机 redis 容器的数据和配置文件目录 123# 这里我们在 /home/docker 下创建mkdir /home/docker/redis/&#123;conf,data&#125; -pcd /home/docker/redis 获取 redis 的默认配置模版 123456789# 获取 redis 的默认配置模版# 这里主要是想设置下 redis 的 log / password / appendonly# redis 的 docker 运行参数提供了 --appendonly yes 但没 passwordwget https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf -O conf/redis.conf# 直接替换编辑sed -i &#x27;s/logfile &quot;&quot;/logfile &quot;access.log&quot;/&#x27; conf/redis.confsed -i &#x27;s/# requirepass foobared/requirepass 123456/&#x27; conf/redis.confsed -i &#x27;s/appendonly no/appendonly yes/&#x27; conf/redis.conf# 这里可能还需配置一些 bind protected-mode 创建并运行一个名为 myredis 的容器 12345678910111213141516# 创建并运行一个名为 myredis 的容器docker run \\-p 6379:6379 \\-v $PWD/data:/data \\-v $PWD/conf/redis.conf:/etc/redis/redis.conf \\--privileged=true \\--name myredis \\-d redis redis-server /etc/redis/redis.conf# 命令分解docker run \\-p 6379:6379 \\ # 端口映射 宿主机:容器-v $PWD/data:/data:rw \\ # 映射数据目录 rw 为读写-v $PWD/conf/redis.conf:/etc/redis/redis.conf:ro \\ # 挂载配置文件 ro 为readonly--privileged=true \\ # 给与一些权限--name myredis \\ # 给容器起个名字-d redis redis-server /etc/redis/redis.conf # deamon 运行容器 并使用配置文件启动容器内的 redis-server 查看活跃的容器 12345678# 查看活跃的容器docker ps# 如果没有 myredis 说明启动失败 查看错误日志docker logs myredis# 查看 myredis 的 ip 挂载 端口映射等信息docker inspect myredis# 查看 myredis 的端口映射docker port myredis 或者使用 shell 登录容器内操作 1docker exec -it myredis bash redis-cli 配置外网可以访问： 更改redis.conf 文件 12bind 127.0.0.1protected-mode yes 更改为 12# bind 127.0.0.1protected-mode no","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhoumoon.github.io/tags/Docker/"}]},{"title":"Spring Boot读取配置的5种方式","slug":"Java/Spring_Boot读取配置的5种方式","date":"2019-12-16T13:41:02.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/16/Java/Spring_Boot读取配置的5种方式/","link":"","permalink":"http://zhoumoon.github.io/2019/12/16/Java/Spring_Boot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Spring Boot读取配置的5种方式 读取application文件 在application.yml或者properties文件中添加： 12345info.address=USAinfo.company=Springinfo.degree=high @Value注解读取方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;`@Component`public class InfoConfig1 &#123;@Value(&quot;$&#123;info.address&#125;&quot;)private String address;@Value(&quot;$&#123;info.company&#125;&quot;)private String company;@Value(&quot;$&#123;info.degree&#125;&quot;)private String degree;public String getAddress() &#123;return address;&#125;public void setAddress(String address) &#123;this.address = address;&#125;public String getCompany() &#123;return company;&#125;public void setCompany(String company) &#123;this.company = company;&#125;public String getDegree() &#123;return degree; &#125;public void setDegree(String degree) &#123;this.degree = degree;&#125;&#125; @ConfigurationProperties注解读取方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Component@ConfigurationProperties(prefix = &quot;info&quot;)public class InfoConfig2 &#123;private String address;private String company;private String degree;public String getAddress() &#123;return address;&#125;public void setAddress(String address) &#123;this.address = address;&#125;public String getCompany() &#123;return company;&#125;public void setCompany(String company) &#123;this.company = company;&#125;public String getDegree() &#123;return degree;&#125;public void setDegree(String degree) &#123;this.degree = degree;&#125;&#125; 读取指定文件 资源目录下建立config/db-config.properties: 123456789101112131415161718192021222324252627282930313233343536373839404142434445db.username=rootdb.password=123456&gt; ### @PropertySource+@Value注解读取方式`@Component`@PropertySource(value = &#123; &quot;config/db-config.properties&quot; &#125;)public class DBConfig1 &#123;@Value(&quot;$&#123;db.username&#125;&quot;)private String username;@Value(&quot;$&#123;db.password&#125;&quot;)private String password;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username = username;&#125;public String getPassword() &#123;return password;&#125;public void setPassword(String password) &#123;this.password = password;&#125;&#125; 注意：@PropertySource不支持yml文件读取。 @PropertySource+@ConfigurationProperties注解读取方式 12345678910111213141516171819202122232425262728293031323334353637@Component@ConfigurationProperties(prefix = &quot;db&quot;)@PropertySource(value = &#123; &quot;config/db-config.properties&quot; &#125;)public class DBConfig2 &#123;private String username;private String password;public String getUsername() &#123;return username;&#125;public void setUsername(String username) &#123;this.username = username;&#125;public String getPassword() &#123;return password;&#125;public void setPassword(String password) &#123;this.password = password;&#125;&#125; Environment读取方式 以上所有加载出来的配置都可以通过Environment注入获取到。 1234567@Autowiredprivate Environment env;// 获取参数`String getProperty(String key); 总结 从以上示例来看，Spring Boot可以通过@PropertySource,@Value,@Environment,@ConfigurationProperties来绑定变量。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Spring Boot 项目获取jar目录","slug":"Java/Spring_Boot_项目获取jar目录","date":"2019-12-16T12:11:12.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/16/Java/Spring_Boot_项目获取jar目录/","link":"","permalink":"http://zhoumoon.github.io/2019/12/16/Java/Spring_Boot_%E9%A1%B9%E7%9B%AE%E8%8E%B7%E5%8F%96jar%E7%9B%AE%E5%BD%95/","excerpt":"","text":"Spring Boot 项目获取jar目录 方式一：获取运行jar目录(不需要考虑在哪运行jar) 12345ApplicationHome home = new ApplicationHome(getClass());File jarFile = home.getSource();jarFile.getParentFile().toString()// file:/D:/WorkSpace/IDEAWorkspace/mapletr4jboot/target 方式二：获取jar内部目录 123String basePatha1 = ClassUtils.getDefaultClassLoader().getResource(&quot;&quot;).getPath();basePatha1 = URLDecoder.decode(basePatha1, &quot;utf-8&quot;);// file:/D:/WorkSpace/IDEAWorkspace/mapletr4jboot/target/mapletr4jboot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"SpringBoot项目jar发布获取jar包所在目录路径","slug":"Java/SpringBoot项目jar发布获取jar包所在目录路径","date":"2019-12-14T17:21:42.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/15/Java/SpringBoot项目jar发布获取jar包所在目录路径/","link":"","permalink":"http://zhoumoon.github.io/2019/12/15/Java/SpringBoot%E9%A1%B9%E7%9B%AEjar%E5%8F%91%E5%B8%83%E8%8E%B7%E5%8F%96jar%E5%8C%85%E6%89%80%E5%9C%A8%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84/","excerpt":"","text":"SpringBoot项目jar发布获取jar包所在目录路径 12345678910111213141516//第一种File path = new File(ResourceUtils.getURL(&quot;classpath:&quot;).getPath());if(!path.exists()) path = new File(&quot;&quot;);System.out.println(path.getAbsolutePath());//第二种System.out.println(System.getProperty(&quot;user.dir&quot;));//第三种String path1 = ClassUtils.getDefaultClassLoader().getResource(&quot;&quot;).getPath();System.out.println(URLDecoder.decode(path1, &quot;utf-8&quot;));//第四种String path2 = ResourceUtils.getURL(&quot;classpath:&quot;).getPath();System.out.println(path2);//第五种ApplicationHome h = new ApplicationHome(getClass());File jarF = h.getSource();System.out.println(jarF.getParentFile().toString()); 这几种获取项目目录的方式中，其中： 第一种、第二种得到的结果一致 第三种、第四种得到的结果一致 但是，不同的运行方式，他们的结果是有偏差的。下面我们来看下不同情况下依次打印的路径是什么。 先看下直接在idea中运行main方法启动项目时候，打印的路径，显示如下： 再看下打包成jar包中，打印的路径 第一种执行方式 操作方式：打开命令行，目录切换到jar包所在目录，然后执行 jar -jar 启动命令，打印的路径如下： 第二种执行方式 操作方式：打开命令行，直接java -jar E:/web_pack/bis_exporter-1.0-SANPSHOT.jar，即不切换到jar所在目录，而是直接执行，打印的路径如下： 是不是发现问题了！在这种情况下，第一种和第二种方式打印的路径是不对的，他打印的路径就是当前执行命令时所在的目录。这就很容易造成不必要的bug。 例如：我们在jar的根目录写一个自定义数据配置文件，通过第一种或者第二种方式读取数据，那么使用远程执行jar的方式，就一定会报找不到配置文件的错误。 总结 综上所述，最好使用第五种方案，获取运行jar所在的目录。 本文转自 https://blog.csdn.net/liangcha007/article/details/88526181，如有侵权，请联系删除。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Spring Cloud 项目打包报没有主清单属性","slug":"Java/springcloud_项目打包_报_没有主清单属性","date":"2019-12-14T16:31:12.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/15/Java/springcloud_项目打包_报_没有主清单属性/","link":"","permalink":"http://zhoumoon.github.io/2019/12/15/Java/springcloud_%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85_%E6%8A%A5_%E6%B2%A1%E6%9C%89%E4%B8%BB%E6%B8%85%E5%8D%95%E5%B1%9E%E6%80%A7/","excerpt":"","text":"Spring Cloud 项目打包报没有主清单属性 项目通过MVN打包，发现打包的文件很小,大概几十KB，估计打包有问题，执行JAVA -JAR 的时候发现果然报错，报 没有主清单属性，网上找了一堆， 都说加 12345678&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 加了之后还是报一样的错误，终于在有一个网上找到 1234567891011121314151617181920212223&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;executions&gt;&lt;execution&gt;&lt;goals&gt;&lt;goal&gt;repackage&lt;/goal&gt;&lt;/goals&gt;&lt;/execution&gt;&lt;/executions&gt;&lt;/plugin&gt;&lt;plugin&gt;&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&lt;configuration&gt;&lt;source&gt;1.8&lt;/source&gt;&lt;target&gt;1.8&lt;/target&gt;&lt;/configuration&gt;&lt;/plugin&gt;&lt;/plugins&gt;&lt;/build&gt; 这样加了以后，生成的JAR包有40多M,把项目的一些依赖包都加载进来了， 这样打包后的文件就可以直接用java -jar 执行了","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Spring Cloud Gateway跨域配置","slug":"Java/Spring_Cloud_Gateway跨域配置","date":"2019-12-14T16:11:42.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/15/Java/Spring_Cloud_Gateway跨域配置/","link":"","permalink":"http://zhoumoon.github.io/2019/12/15/Java/Spring_Cloud_Gateway%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Spring Cloud Gateway跨域配置 1234567891011121314151617181920212223242526272829303132333435/*** 配置跨域* @return*/@Beanpublic CorsWebFilter corsFilter() &#123;CorsConfiguration config = new CorsConfiguration();// cookie跨域config.setAllowCredentials(Boolean.TRUE);config.addAllowedMethod(&quot;*&quot;);config.addAllowedOrigin(&quot;*&quot;);config.addAllowedHeader(&quot;*&quot;);// 配置前端js允许访问的自定义响应头config.addExposedHeader(&quot;setToken&quot;);UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());source.registerCorsConfiguration(&quot;/**&quot;, config);return new CorsWebFilter(source);&#125; 配置不生效方法 官方推荐配置 注意 如果下游服务也配置了跨域处理，会发生配置重复造成错误","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Java 利用反射将父类值赋给子类","slug":"Java/Java_利用反射将父类值赋给子类","date":"2019-12-14T15:21:32.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2019/12/14/Java/Java_利用反射将父类值赋给子类/","link":"","permalink":"http://zhoumoon.github.io/2019/12/14/Java/Java_%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%B0%86%E7%88%B6%E7%B1%BB%E5%80%BC%E8%B5%8B%E7%BB%99%E5%AD%90%E7%B1%BB/","excerpt":"","text":"Java 利用反射将父类值赋给子类 A.java 1234567891011121314151617181920212223242526272829303132333435import java.io.Serializable;import java.util.Set;public class A implements Serializable &#123; private static final long serialVersionUID = 7315556175038040238L; private String a; private String b; private Set&lt;String&gt; names; public String getA() &#123; return a; &#125; public void setA(String a) &#123; this.a = a; &#125; public String getB() &#123; return b; &#125; public void setB(String b) &#123; this.b = b; &#125; public Set&lt;String&gt; getNames() &#123; return names; &#125; public void setNames(Set&lt;String&gt; names) &#123; this.names = names; &#125;&#125; B.java 123456789101112131415161718192021222324import java.io.Serializable;public class B extends A implements Serializable &#123; private static final long serialVersionUID = 2726509261628857907L; private String c; private String d; public String getC() &#123; return c; &#125; public void setC(String c) &#123; this.c = c; &#125; public String getD() &#123; return d; &#125; public void setD(String d) &#123; this.d = d; &#125;&#125; Demo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashSet;import java.util.List;public class Demo &#123; public static void main(String[] args) throws Exception &#123; A a=new A(); B b=new B(); List&lt;String&gt; strings = new ArrayList&lt;&gt;(); strings.add(&quot;111&quot;); strings.add(&quot;2323&quot;); a.setNames(new HashSet&lt;String&gt;(strings)); a.setA(&quot;a&quot;); a.setB(&quot;b&quot;); fatherToChild(a,b); b.getNames().forEach(System.out::println); System.out.println(b.getA()); &#125; public static &lt;T&gt;void fatherToChild(T father,T child) throws Exception &#123; if (child.getClass().getSuperclass()!=father.getClass())&#123; throw new Exception(&quot;child 不是 father 的子类&quot;); &#125; Class&lt;?&gt; fatherClass = father.getClass(); Field[] declaredFields = fatherClass.getDeclaredFields(); for (int i = 0; i &lt; declaredFields.length; i++) &#123; Field field=declaredFields[i]; System.out.println(field.toGenericString()); //防止序列化字段报错 if(field.toGenericString().contains(&quot;final&quot;))&#123; continue; &#125; Method method=fatherClass.getDeclaredMethod(&quot;get&quot;+upperHeadChar(field.getName())); Object obj = method.invoke(father); field.setAccessible(true); field.set(child,obj); &#125; &#125; /** * 首字母大写，in:deleteDate，out:DeleteDate */ public static String upperHeadChar(String in) &#123; String head = in.substring(0, 1); String out = head.toUpperCase() + in.substring(1, in.length()); return out; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Nginx的405错误","slug":"Java/Nginx的405错误","date":"2019-12-14T14:41:32.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/14/Java/Nginx的405错误/","link":"","permalink":"http://zhoumoon.github.io/2019/12/14/Java/Nginx%E7%9A%84405%E9%94%99%E8%AF%AF/","excerpt":"","text":"Nginx的405错误 Nginx将静态文件响应POST请求，提示405错误问题： 绝大多数服务器，都不允许静态文件响应POST请求(GET请求静态文件是天经地义的)，否则会返回HTTP/1.1 405 Method not allowed错误。然而在前端开发中，前端开发工程师经常模拟后端请求，返回静态数据来查看页面效果，怎么办？ 其实很简单，知道404和50x的错误定义吧，那么就是把405重新定义一下即可，如下： error_page 405 =200 $uri; 测试环境局部配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182server &#123;listen 8443 ssl;server_name test-rebuild.baidu.com;ssl_certificate ca.crt;ssl_certificate_key baidu.com.key;ssl_session_cache shared:SSL:1m;ssl_session_timeout 5m;ssl_ciphers HIGH:!aNULL:!MD5;ssl_prefer_server_ciphers on;access_log /var/log/nginx/test-rebuild.aceess.log main;root /usr/share/nginx/html;index index.html index.htm;error_page 405 =200 $uri; _#这里200写成其他数字也可以，比如：255,222等都行，自己定义的，就200好了。_error_page 404 /404.html;location = /40x.html &#123;&#125;error_page 500 502 503 504 /50x.html;location = /50x.html &#123;&#125;&#125;# 其他配置示例## 示例一[https://gist.github.com/baskaran-md/e46cc25ccfac83f153bb](https://gist.github.com/baskaran-md/e46cc25ccfac83f153bb)**server** &#123;listen 80;server_name localhost;location / &#123;root html;index index.html index.htm;&#125;error_page 404 /404.html;error_page 403 /403.html;_# To allow POST on static pages_error_page 405 =200 $uri;_# ..._&#125;## 示例二location ~ \\.(action|jsp) &#123;root $testDataFold;error_page 405 =200 $request_uri;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"获取Servlet的响应并修改其内容","slug":"Java/获取Servlet的响应并修改其内容","date":"2019-12-14T14:41:32.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/14/Java/获取Servlet的响应并修改其内容/","link":"","permalink":"http://zhoumoon.github.io/2019/12/14/Java/%E8%8E%B7%E5%8F%96Servlet%E7%9A%84%E5%93%8D%E5%BA%94%E5%B9%B6%E4%BF%AE%E6%94%B9%E5%85%B6%E5%86%85%E5%AE%B9/","excerpt":"","text":"获取Servlet的响应并修改其内容 有的时候我们需要批量的修改Servlet中的响应的内容，这时候我们就可以通过HttpServletResponseWrapper这个类，在Filter中先获取响应的内容，接着修改响应的内容，最后再把修改完之后的内容作为响应返回给客户端。代码如下演示： 1.创建一个继承自HttpServletResponseWrapper的类 12345678910111213141516171819202122232425262728293031323334353637import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import java.io.CharArrayWriter;import java.io.PrintWriter;/*** Created on 2016/3/29 19:54.*/public class ResponseWrapper extends HttpServletResponseWrapper &#123;private PrintWriter cachedWriter;private CharArrayWriter bufferedWriter;public ResponseWrapper(HttpServletResponse response) &#123;super(response);// 设置响应体格式response.setHeader(&quot;Content-type&quot;, &quot;text/json;charset=UTF-8&quot;);// 这个是我们保存返回结果的地方bufferedWriter = new CharArrayWriter();// 这个是包装PrintWriter的，让所有结果通过这个PrintWriter写入到bufferedWriter中cachedWriter = new PrintWriter(bufferedWriter);&#125;@Overridepublic PrintWriter getWriter() &#123;return cachedWriter;&#125;/*** 获取原始的HTML页面内容。** @return*/public String getResult() &#123;return bufferedWriter.toString();&#125;&#125; 2.在过滤器中修改响应的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.iduoka.util.format;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/*** Created on 2016/3/29 19:55.*/@WebFilter(filterName = &quot;FormatFilter&quot;, urlPatterns = (&quot;/&quot;))public class FormatFilter implements Filter &#123;@Overridepublic void destroy() &#123;// TODO Auto-generated method stub&#125;@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;// 使用我们自定义的响应包装器来包装原始的ServletResponseResponseWrapper wrapper = new ResponseWrapper((HttpServletResponse) response);// 这句话非常重要，注意看到第二个参数是我们的包装器而不是responsechain.doFilter(request, wrapper);// 获取到我们所截获的值 --&gt; 做处理之前所获取到的值String result = wrapper.getResult();// 对返回的结果做处理操作result = result.replace(&quot;&lt;/html&gt;&quot;, &quot;&lt;div style=&#x27;display: none;&#x27;&gt;hello world&lt;/div&gt;\\n&lt;/html&gt;&quot;);// 重置响应输出的内容长度response.setContentLength(-1);// 输出最终的结果 --&gt; 做完处理之后再把这个值返回回去PrintWriter out = response.getWriter();out.write(result);out.flush();out.close();&#125;@Overridepublic void init(FilterConfig filterConfig) throws ServletException &#123;// TODO Auto-generated method stub&#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"获取并打印Spring容器中所有的Bean名称","slug":"Java/获取并打印Spring容器中所有的Bean名称","date":"2019-12-14T13:51:02.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/12/14/Java/获取并打印Spring容器中所有的Bean名称/","link":"","permalink":"http://zhoumoon.github.io/2019/12/14/Java/%E8%8E%B7%E5%8F%96%E5%B9%B6%E6%89%93%E5%8D%B0Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84Bean%E5%90%8D%E7%A7%B0/","excerpt":"","text":"获取并打印Spring容器中所有的Bean名称 思路： 实现Spring的ApplicationContextAware接口，重写setApplicationContext方法，将得到的ApplicationContext对象保存到一个静态变量中，有了这个上下文对象，就可以在项目的任意地方用它来得到任意Bean 调用applicationContext.getBeanDefinitionNames()方法就可以拿到Spring容器中所有的Bean名称;这里为了测试方便就直接在InitializingBean 接口的afterPropertiesSet方法中打印所有Bean名称;启动Spring容器，观察控制台即可看到打印结果，打印Spring容器中所有Bean在项目调试的时候很有用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import org.springframework.beans.BeansException;import org.springframework.beans.factory.InitializingBean;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;/*** 打印Spring容器所有的Bean名称** @author syj*/@Componentpublic class ApplicationContextBean implements ApplicationContextAware, InitializingBean &#123;public static ApplicationContext applicationContext;/*** 获取 ApplicationContext** @param applicationContext* @throws BeansException*/@Overridepublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;ApplicationContextBean.applicationContext = applicationContext;&#125;/*** 打印IOC容器中所有的Bean名称** @throws Exception*/@Overridepublic void afterPropertiesSet() throws Exception &#123;String[] names = applicationContext.getBeanDefinitionNames();for (String name : names) &#123;System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&quot; + name);&#125;System.out.println(&quot;------\\nBean 总计:&quot; + applicationContext.getBeanDefinitionCount());&#125;&#125; 还有一种更简单的方式，直接使用@Autowired注入ApplicationContext对象： 123456789101112131415161718192021222324252627282930313233343536373839404142import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Arrays;import java.util.List;@RestController@RequestMappingpublic class BeanController &#123;@Autowiredprivate ApplicationContext applicationContext;@GetMapping(&quot;/beanList&quot;)public List&lt;String&gt; beanList() &#123;return Arrays.asList(applicationContext.getBeanDefinitionNames());&#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"为什么 Java 中只有值传递？","slug":"Java/为什么 Java 中只有值传递？","date":"2019-09-11T11:23:12.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/09/11/Java/为什么 Java 中只有值传递？/","link":"","permalink":"http://zhoumoon.github.io/2019/09/11/Java/%E4%B8%BA%E4%BB%80%E4%B9%88%20Java%20%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F/","excerpt":"","text":"首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。 Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 下面通过 3 个例子来给大家说明 example 1 123456789101112131415161718public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(&quot;num1 = &quot; + num1); System.out.println(&quot;num2 = &quot; + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b);&#125; 结果： 1234a = 20b = 10num1 = 10num2 = 20 解析： 在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2. example 2 1234567891011public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);&#125;public static void change(int[] array) &#123; // 将数组的第一个元素变为0 array[0] = 0;&#125; 结果： 1210 解析： array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。 通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。 example 3 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Student s1 = new Student(&quot;小张&quot;); Student s2 = new Student(&quot;小李&quot;); Test.swap(s1, s2); System.out.println(&quot;s1:&quot; + s1.getName()); System.out.println(&quot;s2:&quot; + s2.getName()); &#125; public static void swap(Student x, Student y) &#123; Student temp = x; x = y; y = temp; System.out.println(&quot;x:&quot; + x.getName()); System.out.println(&quot;y:&quot; + y.getName()); &#125;&#125; 结果： 1234x:小李y:小张s1:小张s2:小李 解析： 交换之前： 交换之后： 通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝 总结 Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。 下面再总结一下Java中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 参考： 《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节 二 ==与equals(重要) == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型比较的是值，引用数据类型比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。 举个例子： 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(&quot;ab&quot;); // a 为一个引用 String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样 String aa = &quot;ab&quot;; // 放在常量池中 String bb = &quot;ab&quot;; // 从常量池中查找 if (aa == bb) // true System.out.println(&quot;aa==bb&quot;); if (a == b) // false，非同一对象 System.out.println(&quot;a==b&quot;); if (a.equals(b)) // true System.out.println(&quot;aEQb&quot;); if (42 == 42.0) &#123; // true System.out.println(&quot;true&quot;); &#125; &#125;&#125; 说明： String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。 三 hashCode与equals（重要） 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” hashCode（）介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。 1234567891011121314151617/** * Returns a hash code value for the object. This method is * supported for the benefit of hash tables such as those provided by * &#123;@link java.util.HashMap&#125;. * &lt;p&gt; * As much as is reasonably practical, the hashCode method defined by * class &#123;@code Object&#125; does return distinct integers for distinct * objects. (This is typically implemented by converting the internal * address of the object into an integer, but this implementation * technique is not required by the * Java&amp;trade; programming language.) * * @return a hash code value for this object. * @see java.lang.Object#equals(java.lang.Object) * @see java.lang.System#identityHashCode */public native int hashCode(); 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有hashCode 我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode： 当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。 hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 为什么两个对象有相同的hashcode值，它们也不一定是相等的？ 在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。 因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。 参考： https://blog.csdn.net/zhzhao999/article/details/53449504 https://www.cnblogs.com/skywang12345/p/3324958.html https://www.cnblogs.com/Eason-S/p/5524837.html","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"干货：计算机网络知识总结","slug":"other/干货：计算机网络知识总结","date":"2019-09-11T04:03:11.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/09/11/other/干货：计算机网络知识总结/","link":"","permalink":"http://zhoumoon.github.io/2019/09/11/other/%E5%B9%B2%E8%B4%A7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"目录结构 1. 计算机概述 2. 物理层 3. 数据链路层 4. 网络层 5. 运输层 6. 应用层 一计算机概述 （1），基本术语 结点 （node）： 网络中的结点可以是计算机，集线器，交换机或路由器等。 链路（link ）： 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。 主机（host）： 连接在因特网上的计算机. ISP（Internet Service Provider）： 因特网服务提供者（提供商）. IXP（Internet eXchange Point）： 互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。. RFC(Request For Comments) 意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。 广域网WAN（Wide Area Network） 任务是通过长距离运送主机发送的数据 城域网MAN（Metropolitan Area Network） 用来讲多个局域网进行互连 局域网LAN（Local Area Network） 学校或企业大多拥有多个互连的局域网 个人区域网PAN（Personal Area Network） 在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 端系统（end system）： 处在因特网边缘的部分即是连接在因特网上的所有的主机. 分组（packet ）： 因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。 存储转发（store and forward ）: 路由器收到一个分组，先存储下来，再检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。 带宽（bandwidth）： 在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。 吞吐量（throughput ）： 表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。 （2），重要知识点总结 1，计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。 2，小写字母i开头的internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。 大写字母I开头的Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用TCP/IP协议作为通信规则，其前身为ARPANET。Internet的推荐译名为因特网，现在一般流行称为互联网。 3，路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。 4，互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。 5，计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。 6，客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。 7，按照作用范围的不同，计算机网络分为广域网WAN，城域网MAN，局域网LAN，个人区域网PAN。 8，计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。 9，网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。 10，五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。 二物理层 （1），基本术语 数据（data）： 运送消息的实体。 信号（signal）： 数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。 码元（ code）： 在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。 单工（simplex ）： 只能有一个方向的通信而没有反方向的交互。 半双工（half duplex ）： 通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 全双工（full duplex）： 通信的双方可以同时发送和接收信息。 奈氏准则： 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。 基带信号（baseband signal）： 来自信源的信号。指没有经过调制的数字信号或模拟信号。 带通（频带）信号（bandpass signal）： 把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。 调制（modulation ）： 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。 信噪比（signal-to-noise ratio ）： 指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N） 信道复用（channel multiplexing ）： 指多个用户共享同一个信道。（并不一定是同时） 比特率（bit rate ）： 单位时间（每秒）内传送的比特数。 波特率（baud rate）： 单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。 复用（multiplexing）： 共享信道的方法 ADSL（Asymmetric Digital Subscriber Line ）： 非对称数字用户线。 光纤同轴混合网（HFC网）: 在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网 （2），重要知识点总结 1，物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。 2，一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。 3，通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。 4，根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。 5，根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。 6，来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。 7，要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。 8，传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。 9，为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。 （3），最重要的知识点 ①，物理层的任务 透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。 拓展： 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。 ②，几种常用的信道复用技术 ③，几种常用的宽带接入技术，主要是ADSL和FTTx 用户到互联网的宽带接入方法有非对称数字用户线ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL的快速版本是甚高速数字用户线VDSL。），光纤同轴混合网HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和FTTx（即光纤到······）。 三数据链路层 （1），基本术语 链路（link）： 一个结点到相邻结点的一段物理链路 数据链路（data link）： 把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路 循环冗余检验CRC（Cyclic Redundancy Check）： 为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术 帧（frame）： 一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。 MTU（Maximum Transfer Uint ）： 最大传送单元。帧的数据部分的的长度上限。 误码率BER（Bit Error Rate ）： 在一段时间内，传输错误的比特占所传输比特总数的比率。 PPP（Point-to-Point Protocol ）： 点对点协议。即用户计算机和ISP进行通信时所使用的数据链路层协议。以下是PPP帧的示意图: MAC地址（Media Access Control或者Medium Access Control）： 意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。 在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。 因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址 。 地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处” 网桥（bridge）： 一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。 交换机（switch ）： 广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥 （2），重要知识点总结 1，链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现） 2，数据链路层使用的主要是点对点信道和广播信道两种。 3，数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：封装成帧，透明传输和差错检测 4，循环冗余检验CRC是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码 5，点对点协议PPP是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议 6，PPPoE是为宽带上网的主机使用的链路层协议 7，局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。 8，共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入） 9，计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。计算器的硬件地址就在适配器的ROM中。 10，以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做 11，以太网采用的协议是具有冲突检测的载波监听多点接入CSMA/CD。协议的特点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道 12，以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。 13，使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络） （3），最重要的知识点 ① 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议以及CSMA/CD协议）的特点 ② 数据链路层的三个基本问题：封装成帧，透明传输，差错检测 ③ 以太网的MAC层硬件地址 ④ 适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合 四网络层 （1），基本术语 虚电路（Virtual Circuit）： 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。 IP（Internet Protocol ）： 网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。 ARP（Address Resolution Protocol）： 地址解析协议 ICMP（Internet Control Message Protocol ）： 网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。） 子网掩码（subnet mask ）： 它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。 CIDR（ Classless Inter-Domain Routing ）： 无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号） 默认路由（default route）： 当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。 路由选择算法（Virtual Circuit）： 路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。 （2），重要知识点总结 1，TCP/IP协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责 2，在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付 3，分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址市一中分等级的地址结构。IP地址管理机构分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址 4，IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止IP数据报在互联网中无限制的兜圈子。 5，地址解析协议ARP把IP地址解析为硬件地址。ARP的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送ARP请求分组 6，无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。 7， 网际控制报文协议是IP层的协议.ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种 ICMP差错报告报文和ICMP询问报文。 8，要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址弓箭的新版本IP协议-IPv6。IPv6所带来的变化有①更大的地址空间（采用128位地址）②灵活的首部格式③改进的选项④支持即插即用⑤支持资源的预分配⑥IPv6的首部改为8字节对齐。另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播 9，虚拟专用网络VPN利用公用的互联网作为本机构专用网之间的通信载体。VPN内使用互联网的专用地址。一个VPN至少要有一个路由器具有合法的全球IP地址，这样才能和本系统的另一个VPN通过互联网进行通信。所有通过互联网传送的数据都需要加密 10， MPLS的特点是：①支持面向连接的服务质量②支持流量工程，平衡网络负载③有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。 （3），最重要知识点 ① 虚拟互联网络的概念 ② IP地址和物理地址的关系 ③ 传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR ④ 路由选择协议的工作原理 五运输层 （1），基本术语 进程（process）： 指计算机中正在运行的程序实体 应用进程互相通信： 一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信） 传输层的复用与分用： 复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 TCP（Transmission Control Protocol）： 传输控制协议 UDP（User Datagram Protocol）： 用户数据报协议 端口（port）（link）： 端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 停止等待协议（link）： 指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。 流量控制（link）： 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。 拥塞控制（link）： 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。 （2），重要知识点总结 1，运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。 2，网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。 3，运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。 4，UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。 5，硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)） 6，运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。 7，运输层的端口号分为服务器端使用的端口号（01023指派给熟知端口，102449151是登记端口号）和客户端暂时使用的端口号（49152~65535） 8，UDP的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和） 9，TCP的主要特点是①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流 10，TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。 11，停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 12，为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。 13，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。 14，TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。 15，TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不晕与发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 16，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 17，为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。 18，TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。 19，运输连接的三个阶段，即：连接建立，数据传送和连接释放。 20，主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。 21，TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接 （3），最重要的知识点 ① 端口和套接字的意义 ② 无连接UDP的特点 ③ 面向连接TCP的特点 ④ 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议 ① TCP的滑动窗口，流量控制，拥塞控制和连接管理 六应用层 （1），基本术语 域名系统（DNS）： DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。 文件传输协议（FTP）： FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。 基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。 &quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。 简单文件传输协议（TFTP）： TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。 远程终端协议（TELENET）： Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。 可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。 万维网（WWW）： WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为Web。分为Web客户端和Web服务器程序。 WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。 万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。 万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。 万维网的大致工作工程： 统一资源定位符（URL）： 统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 超文本传输协议（HTTP）： 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。 代理服务器（Proxy Server）： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。 代理服务器可在客户端或服务器工作，也可以在中间系统工作。 http请求头： http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。 - Accept：浏览器可接受的MIME类型。 - Accept-Charset：浏览器可接受的字符集。 - Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。 - Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 - Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。 - Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。 - Content-Length：表示请求消息正文的长度。 - Cookie：这是最重要的请求头信息之一 - From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。 - Host：初始URL中的主机和端口。 - If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。 - Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。 - Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 - User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。 简单邮件传输协议(SMTP)： SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。 搜索引擎： 搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。 搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。 全文索引： 全文索引技术是目前搜索引擎的关键技术。 试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。 所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。 目录索引： 目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。 垂直搜索引擎： 垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。 垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。 其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。 （2），重要知识点总结 1，文件传输协议（FTP）使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP的客户和服务器之间要先建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。 2，万维网客户程序与服务器之间进行交互使用的协议时超文本传输协议HTTP。HTTP使用TCP连接进行可靠传输。但HTTP本身是无连接、无状态的。HTTP/1.1协议使用了持续连接（分为非流水线方式和流水线方式） 3，电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。 4，一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如SMTP，和邮件读取协议，如POP3和IMAP）。用户代理和邮件服务器都要运行这些协议。 （3），最重要知识点总结 ① 域名系统-从域名解析出IP地址 ② 访问一个网站大致的过程 ③ 系统调用和应用编程接口概念","categories":[],"tags":[{"name":"Http","slug":"Http","permalink":"http://zhoumoon.github.io/tags/Http/"}]},{"title":"Java修改项目web访问根目录","slug":"Java/java修改项目web访问根目录","date":"2019-08-14T13:31:22.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2019/08/14/Java/java修改项目web访问根目录/","link":"","permalink":"http://zhoumoon.github.io/2019/08/14/Java/java%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AEweb%E8%AE%BF%E9%97%AE%E6%A0%B9%E7%9B%AE%E5%BD%95/","excerpt":"","text":"Java修改项目web访问根目录 在开发Java WEB项目时可能需要修改项目访问的根目录，例如http://localhost:8080/test, ”test“是web项目访问根目录（这里只是个人这么称呼，并不是官方术语）。可能需求不同，在访问的时候不需要test或者是需要更换成别的名称。总而言之，就是不需要当前默认项目名称作为web访问根目录。那么如何修改？ 直接通过开发工具修改，这里以Eclipse为例。在Eclipse中选择项目，然后点击“project&quot;,选择properties选项，在配置窗口选择”Web Project Settings“选项，最后修改想要的名称即可。 通过Tomcat设置，这里比较局限，因为本人还没有用过其他容器。 在tomcat根目录下打开conf文件夹，然后编辑server.xml. 找到标签，在该标签中填入一下内容 1&lt;Context path=&quot;/webrootName&quot; docBase=&quot;realPath&quot; &gt;&lt;/Context&gt; 这里只用到path，docBase两个属性。分表表示web应用根目录和项目所在文件路径。 修改完成后，重启tomcat服务，直接访问http://localhost:8080/webrootName 即能访问部署的项目。 注：这里http://localhost:8080/只是测试案例，需要按照各自环境变化。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Java多线程之内存可见性","slug":"Java/Java多线程之内存可见性","date":"2019-08-13T15:59:37.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2019/08/13/Java/Java多线程之内存可见性/","link":"","permalink":"http://zhoumoon.github.io/2019/08/13/Java/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/","excerpt":"","text":"Java多线程之内存可见性 可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到; 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是几个线程的共享变量。 Java内存模型（JMM) Java内存模型（Java Memory Model） 描述了Java程序中个各种变量 （线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节; 所有的变量都存储在主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量 副本（主内存中该变量的一份拷贝） 两条规定： 线程对共享变量的所有操作必须在自己的工作内存中进行，不能直接从主内存中读写 不同线程无法直接访问其他线程工作内存的变量，线程间变量值传递需要通过主内存来完成 共享变量可见性实现的原理 线程1对共享变量的修改想要被线程2及时看到，必须经过如下2个步骤： 把工作内存1中更新过的共享变量刷新到主内存中 将主内存最新的共享变量的值更新到工作内存2中 synchronized实现可见性 synchronized 能够实现： 原子性（同步） 可见性 原子性和可见性JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中； 线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量需要从主内存中重新读取最新的值（注意：加锁和解锁需要是同一把锁）","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Java Tree 递归实现(项目中实际应用)","slug":"Java/Java_Tree_递归实现(项目中实际应用)","date":"2019-08-13T15:23:10.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2019/08/13/Java/Java_Tree_递归实现(项目中实际应用)/","link":"","permalink":"http://zhoumoon.github.io/2019/08/13/Java/Java_Tree_%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0(%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8)/","excerpt":"","text":"Java Tree 递归实现(项目中实际应用) Java Tree 递归实现(项目中实际应用) 部门Bean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;import java.util.List;public class Department &#123; private int id; private String name; private int parentId; private List&lt;Department&gt; children = new ArrayList&lt;Department&gt;(); public Department(int id, String name, int parentId) &#123; this.id = id; this.name = name; this.parentId = parentId; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getParentId() &#123; return parentId; &#125; public void setParentId(int parentId) &#123; this.parentId = parentId; &#125; public List&lt;Department&gt; getChildren() &#123; return children; &#125; public void setChildren(List&lt;Department&gt; children) &#123; this.children = children; &#125; @Override public String toString() &#123; return &quot;Department&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, parentId=&quot; + parentId + &quot;, children=&quot; + children + &#x27;&#125;&#x27;; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;import java.util.List;public class DempartmentThree &#123; public static void main(String[] args) &#123; List&lt;Department&gt; departmentList = new ArrayList&lt;&gt;(); departmentList.add(new Department(1, &quot;研发部门&quot;, 0)); departmentList.add(new Department(2, &quot;研发团队1&quot;, 1)); departmentList.add(new Department(3, &quot;研发团队2&quot;, 1)); departmentList.add(new Department(4, &quot;财务部门&quot;, 0)); departmentList.add(new Department(5, &quot;财务A部门&quot;, 4)); departmentList.add(new Department(6, &quot;财务B部门&quot;, 4)); departmentList.add(new Department(7, &quot;财务A部门团队1&quot;, 5)); departmentList.add(new Department(8, &quot;财务A部门团队2&quot;, 5)); departmentList.add(new Department(9, &quot;财务B部门团队1&quot;, 6)); departmentList.add(new Department(10, &quot;财务B部门团队2&quot;, 6)); List&lt;Department&gt; listTree = getThree(departmentList,0); //Tree System.out.println(listTree); System.out.println(&quot;--------------&quot;); //由Tree某个节点及其子节点组成的姓名集合 //System.out.println(getTreeName(listTree.get(0))); &#125; private static List&lt;Department&gt; getThree(List&lt;Department&gt; list,int parentId)&#123; //获取所有子节点 List&lt;Department&gt; childTreeList = getChildTree(list,parentId); for (Department dept:childTreeList) &#123; dept.setChildren(getThree(list,dept.getId())); &#125; return childTreeList; &#125; private static List&lt;Department&gt; getChildTree(List&lt;Department&gt; list,int id)&#123; List&lt;Department&gt; childTree = new ArrayList&lt;&gt;(); for (Department dept:list) &#123; if(dept.getParentId() == id)&#123; childTree.add(dept); &#125; &#125; return childTree; &#125;&#125; 使用队列将树结构转换为list 123456789101112131415161718//取出上述部门Tree中的某个节点及其所有子节点的name值//利用队列的特点(先进先出)private static List&lt;String&gt; getTreeName(Department department) &#123; //部门名称集合 List&lt;String&gt; names = new ArrayList&lt;String&gt;(); //部门队列 Queue&lt;Department&gt; queue = new LinkedList&lt;Department&gt;(); //先将树顶压入队列 queue.add(department); while (!queue.isEmpty()) &#123; //从队列取出 Department d = queue.remove(); names.add(d.getName()); queue.addAll(d.getChildren()); &#125; return names;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Java生成MD5的坑","slug":"Java/Java生成MD5的坑","date":"2019-08-13T14:53:22.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2019/08/13/Java/Java生成MD5的坑/","link":"","permalink":"http://zhoumoon.github.io/2019/08/13/Java/Java%E7%94%9F%E6%88%90MD5%E7%9A%84%E5%9D%91/","excerpt":"","text":"Java生成MD5的坑 Java生成MD5的坑 本来一切都风平浪静，今天接口调用方突然在群里艾特我，说调接口的时候返回鉴权失败。 其中r和t是用来参与加密运算的字符串，然后双方都持有已知的公钥，所以在代码中进行如下的计算： DataCenterUtils.getMD5(r + t + SECRET_KEY) 得到的结果和sign做比较，一致则验证通过。 问题就出在计算出md5值之后，转化成String类型的过程，之前的哥们是这么转化的： 12345678910111213public static String getMD5(String str) throws Exception&#123;// 生成一个MD5加密计算摘要_MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);// 计算md5函数_md.update(str.getBytes());return new BigInteger(1, md.digest()).toString(16);&#125; 乍一看没有问题，很多人也是这么做的，但是如果得到的md5结果是以0开头的，那结果就悲剧了，转化为数值类型的时候会将开头的0丢弃，所以造成结果和sign不一致的情况出现！ 将代码进行如下修改后，问题解决： 12345678910111213141516171819202122232425262728293031public static String getMD5(String str) throws Exception&#123;// 生成一个MD5加密计算摘要MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);// 计算md5函数md.update(str.getBytes());return toHexString(md.digest());&#125;private static String toHexString(byte[] bytes) &#123;Formatter formatter = new Formatter();for (byte b : bytes) &#123;formatter.format(&quot;%02x&quot;, b);&#125;String res = formatter.toString();formatter.close();return res;&#125; 利用formatter将字节一个个的转为十六进制的形式即可！","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"Java 文件处理","slug":"Java/Java文件_文件处理","date":"2019-08-13T01:13:11.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2019/08/13/Java/Java文件_文件处理/","link":"","permalink":"http://zhoumoon.github.io/2019/08/13/Java/Java%E6%96%87%E4%BB%B6_%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"Java 文件处理 1、获取文件-文件夹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UtilFile &#123; /** * 递归获取某个文件夹下的所有文件 * * @param fileNameList * 存放文件名称的list * @param path * 文件夹的路径 * @return 文件名称 */ public static ArrayList&lt;String&gt; getAllFileName(String path, ArrayList&lt;String&gt; fileNameList) &#123; ArrayList&lt;String&gt; files = new ArrayList&lt;String&gt;(); File file = new File(path); File[] tempList = file.listFiles(); for (int i = 0; i &lt; tempList.length; i++) &#123; if (tempList[i].isFile()) &#123; // 文件路径 // System.out.println(&quot;文 件：&quot; + tempList[i]); // fileNameList.add(tempList[i].toString()); String fName = tempList[i].toString(); File tempFile = new File(fName.trim()); String fileName = tempFile.getName(); // System.out.println(&quot;fileName = &quot; + fileName); // 获取文件名称添加入list files.add(fileName); fileNameList.add(tempList[i].getName()); &#125; if (tempList[i].isDirectory()) &#123; // 文件夹路径 // System.out.println(&quot;文件夹：&quot; + tempList[i]); getAllFileName(tempList[i].getAbsolutePath(), fileNameList); &#125; &#125; return files; &#125; public static void main(String[] args) &#123; ArrayList&lt;String&gt; files = new ArrayList&lt;String&gt;(); files = UtilFile.getAllFileName(&quot;E:/apache-tomcat-8.5.15/webapps/mexx/excel&quot;, new ArrayList&lt;String&gt;()); for (String string : files) &#123; System.out.println(&quot;文件名:&quot; + string); &#125; &#125;&#125; files:返回的文件名 tempList[i].toString():获取到的文件或文件夹完整路径 重点 省去了切割字符串,步骤,避免在不同平台路径问题,直接可以拿到路径最后的文件名 1234String fName =&quot;E:/apache-tomcat-8.5.15/webapps/mexx/excel&quot;;File tempFile = new File(fName.trim());String fileName = tempFile.getName();System.out.println(&quot;fileName = &quot; + fileName); 2、文件下载 Controller 1234567891011121314151617181920212223242526272829 /** * 文件下载 * * @throws IOException */@RequestMapping(value = &quot;/download&quot;, method = RequestMethod.GET)public void download(@RequestParam(value = &quot;filename&quot;) String filename, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; // 模拟文件，myfile.txt为需要下载的文件 //String path = request.getSession().getServletContext().getRealPath(&quot;Excel&quot;) + &quot;\\\\&quot; + filename; String path =EXCEL_URL + &quot;/&quot; + filename; // 获取输入流 InputStream bis = new BufferedInputStream(new FileInputStream(new File(path))); // 转码，免得文件名中文乱码 filename = URLEncoder.encode(filename, &quot;UTF-8&quot;); // 设置文件下载头 response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + filename); // 1.设置文件ContentType类型，这样设置，会自动判断下载文件类型 response.setContentType(&quot;multipart/form-data&quot;); BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream()); int len = 0; while ((len = bis.read()) != -1) &#123; out.write(len); out.flush(); &#125; out.close(); System.out.println(ExcelController.getIpAddr(request)+&quot;下载完成&quot;);&#125; 3、前端显示 12345&lt;div style=&quot;margin-top:30px;&quot;&gt; &lt;c:forEach items=&quot;$&#123;filesList &#125;&quot; var=&quot;fileName&quot; &gt; &lt;button type=&quot;button&quot; &gt;$&#123;fileName&#125;&lt;/button&gt; &lt;/c:forEach&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"MySQL高性能优化规范建议","slug":"DB/docker安装Oracle_11g","date":"2018-11-15T14:42:02.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2018/11/15/DB/docker安装Oracle_11g/","link":"","permalink":"http://zhoumoon.github.io/2018/11/15/DB/docker%E5%AE%89%E8%A3%85Oracle_11g/","excerpt":"","text":"docker安装Oracle 11g 操作系统切换到root用户： 1su root 启动docker 1systemctl start docker 拉取oracle镜像(oracle 11.0.2 64bit 企业版 实例名: helowin) 1docker pull [registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g](http://registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g) 创建并启动容器（映射本地端口1521) 1234567docker run \\--name oracle \\-p 1521:1521 \\-d [registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g](http://registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g) 进入docker的oracle_11g 容器 1docker exec -it 容器ID /bin/bash 加载环境变量 1source /home/oracle/.bash_profile 登录sqlplus 1234sqlplus /nologsql&gt; connect /as sysdba# 到这里就可以进行您想要的任何操作了# 容器操作系统用户 root：helowin 如需用plsql等工具连接 请设置用户和密码(oracle 11.0.2 64bit 企业版 实例名: helowin)。例： 12sql&gt; create user test identified by test;sql&gt; grant connect,resource,dba to test; 如需映射oracle的数据文件 把容器内对应的文件，拷贝到宿主机，映射即可（如下） 12/home/oracle/app/oracle/oradata//home/oracle/app/oracle/flash_recovery_area/helowin/ 推荐使用docker-compose管理 参考：https://dev.aliyun.com/detail.html?spm=5176.1972343.2.2.jhKAjR&amp;repoId=1969","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://zhoumoon.github.io/tags/Oracle/"}]},{"title":"plsql连接本地Oracle","slug":"DB/plsql连接本地Oracle","date":"2018-11-03T11:22:00.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2018/11/03/DB/plsql连接本地Oracle/","link":"","permalink":"http://zhoumoon.github.io/2018/11/03/DB/plsql%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0Oracle/","excerpt":"","text":"plsql连接本地Oracle https://www.cnblogs.com/hongten/p/hongten_oracle_plsql.htm 我们把oracle成功的安装在了我们的计算机上面，那我们如何才能将PLSQL developer连 接到本地的oracle呢？ 首先，我们必须有下面步准备： 1.安装好Oracle 2.安装好PLSQL developer 下面就是让PLSQL developer连接到oracle数据库的操作步骤了 选择：Net Configuration Assistant(红色框所指) 启动 点击下一步 点击下一步 名字可以任意，点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 选择本地Net服务名配置，点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 点击下一步 点击完成按钮 启动PLSQL，数据库选择为：ORACT 连接成功！","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://zhoumoon.github.io/tags/Oracle/"}]},{"title":"MySQL id从1开始自增 解决id不连续的问题","slug":"DB/mysql_id从1开始自增_解决id不连续的问题-LancerWu的博客-CSDN博客","date":"2018-02-03T23:11:02.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2018/02/04/DB/mysql_id从1开始自增_解决id不连续的问题-LancerWu的博客-CSDN博客/","link":"","permalink":"http://zhoumoon.github.io/2018/02/04/DB/mysql_id%E4%BB%8E1%E5%BC%80%E5%A7%8B%E8%87%AA%E5%A2%9E_%E8%A7%A3%E5%86%B3id%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%97%AE%E9%A2%98-LancerWu%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"MySQL id从1开始自增 解决id不连续的问题 TRUNCATE TABLE tablename 来实现id从头自增，但是这个命令同时也会清空整个表 正确的做法： alter table tablename auto_increment = 1; 这个命令不会改动现有的表的内容和顺序，同时新插入行的id会先使用已删除的id，完美填补空缺id。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhoumoon.github.io/tags/MySQL/"}]},{"title":"一千行MySQL命令","slug":"DB/一千行MySQL命令","date":"2018-02-03T23:11:02.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2018/02/04/DB/一千行MySQL命令/","link":"","permalink":"http://zhoumoon.github.io/2018/02/04/DB/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4/","excerpt":"","text":"一千行MySQL命令 非常不错的总结，强烈建议保存下来，需要的时候看一看。 基本操作 数据库操作 表的操作 数据操作 字符集编码 数据类型(列类型) 列属性(列约束) 建表规范 SELECT UNION 子查询 连接查询(join) TRUNCATE 备份与还原 视图 事务(transaction) 锁表 触发器 SQL编程 存储过程 用户和权限管理 表维护 杂项 基本操作 123456789/* Windows服务 */-- 启动MySQL net start mysql-- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)/* 连接与断开服务器 */mysql -h 地址 -P 端口 -u 用户名 -p 密码SHOW PROCESSLIST -- 显示哪些线程正在运行SHOW VARIABLES -- 显示系统变量信息 数据库操作 12345678910111213141516171819/* 数据库操作 */ -------------------- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name-- 查看已有库 SHOW DATABASES[ LIKE &#x27;PATTERN&#x27;]-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容 表的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 创建表 CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#x27;string&#x27;]-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = &#x27;目录&#x27; -- 索引文件目录 INDEX DIRECTORY = &#x27;目录&#x27; -- 表注释 COMMENT = &#x27;string&#x27; -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE &#x27;pattern&#x27;] SHOW TABLES FROM 库名-- 查看表机构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#x27;PATTERN&#x27;] SHOW TABLE STATUS [FROM db_name] [LIKE &#x27;pattern&#x27;]-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[ COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名)-- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 数据操作 1234567891011121314151617/* 数据操作 */ -------------------- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]-- 查 SELECT 字段列表 FROM 表名[ 其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段-- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部-- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码 123456789101112131415161718/* 字符集编码 */ -------------------- MySQL、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致SHOW VARIABLES LIKE &#x27;character_set_%&#x27; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置-- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE &#x27;pattern&#x27;]/SHOW CHARSET [LIKE &#x27;pattern&#x27;] 查看所有字符集 SHOW COLLATION [LIKE &#x27;pattern&#x27;] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码 数据类型(列类型) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* 数据类型（列类型） */ ------------------1. 数值类型-- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&#x27;123&#x27;，补填后为&#x27;00123&#x27; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。-- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。2. 字符串类型-- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值-- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob.3. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155datetime YYYY-MM-DD hh:mm:sstimestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmssdate YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDDtime hh:mm:ss hhmmss hhmmssyear YYYY YY YYYY YY4. 枚举和集合-- 枚举(enum) ----------enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。-- 集合（set） ----------set(val1, val2, val3...) create table tab ( gender set(&#x27;男&#x27;, &#x27;女&#x27;, &#x27;无&#x27;) ); insert into tab values (&#x27;男, 女&#x27;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 列属性(列约束) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* 列属性（列约束） */ ------------------1. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &#x27;val&#x27;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, &#x27;val&#x27;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. COMMENT 注释 例：create table tab ( id int ) comment &#x27;注释内容&#x27;;7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 建表规范 1234567891011121314/* 建表规范 */ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除复合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 SELECT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* SELECT */ ------------------SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb;b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 UNION 12345678/* UNION */ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 子查询 1234567891011121314151617181920212223242526272829/* 子查询 */ ------------------ - 子查询需用括号包裹。-- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;-- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询(join) 123456789101112131415161718192021222324/* 连接查询(join) */ ------------------ 将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2;-- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right joinselect info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; TRUNCATE 123456789/* TRUNCATE */ ------------------TRUNCATE [TABLE] tbl_name清空数据删除重建表区别：1，truncate 是删除表再创建，delete 是逐条删除2，truncate 重置auto_increment的值。而delete不会3，truncate 不知道删除了几条，而delete知道。4，当被用于带分区的表时，truncate 会保留分区 备份与还原 123456789101112131415161718192021/* 备份与还原 */ ------------------备份，将数据的结构与表内数据保存起来。利用 mysqldump 指令完成。-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database DB1 [DB2 DB3...]mysqldump [options] --all--database1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)可以-w携带WHERE条件-- 导入1. 在登录mysql的情况下： source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图 1234567891011121314151617181920212223242526272829什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。-- 创建视图CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数-- 查看结构 SHOW CREATE VIEW view_name-- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ...-- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement-- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构-- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 事务(transaction) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。-- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。-- 事务提交 COMMIT;-- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。-- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点-- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表 1234567/* 锁表 */表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁-- 锁定 LOCK TABLES tbl_name [AS alias]-- 解锁 UNLOCK TABLES 触发器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 触发器 */ ------------------ 触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象 监听：记录的增加、修改、删除。-- 创建触发器CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt 参数： trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。 trigger_event指明了激活触发程序的语句的类型 INSERT：将新行插入表时激活触发程序 UPDATE：更改某一行时激活触发程序 DELETE：从表中删除某一行时激活触发程序 tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。 trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构-- 删除DROP TRIGGER [schema_name.]trigger_name可以使用old和new代替旧的和新的数据 更新操作，更新前是old，更新后是new. 删除操作，只有old. 增加操作，只有new.-- 注意 1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。-- 字符连接函数concat(str1,str2,...])concat_ws(separator,str1,str2,...)-- 分支语句if 条件 then 执行语句elseif 条件 then 执行语句else 执行语句end if;-- 修改最外层语句结束符delimiter 自定义结束符号 SQL语句自定义结束符号delimiter ; -- 修改回原来的分号-- 语句块包裹begin 语句块end-- 特殊的执行1. 只要添加记录，就会触发程序。2. Insert into on duplicate key update 语法会触发： 如果没有重复记录，会触发 before insert, after insert; 如果有重复记录并更新，会触发 before insert, before update, after update; 如果有重复记录但是没有发生更新，则触发 before insert, before update3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert SQL编程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* SQL编程 */ --------------------// 局部变量 ------------ 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10; - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then statement_list [elseif search_condition then statement_list]...[else statement_list]end if;-- case语句CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END-- while循环[begin_label:] while search_condition do statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环--// 内置函数 ------------ 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date(&#x27;yyyy-mm-dd hh:ii:ss&#x27;); -- 获取日期部分time(&#x27;yyyy-mm-dd hh:ii:ss&#x27;); -- 获取时间部分date_format(&#x27;yyyy-mm-dd hh:ii:ss&#x27;, &#x27;%d %y %a %d %m %b %j&#x27;); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end 多分支if(expr1,expr2,expr3) 双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();--// 存储函数，自定义函数 ------------ 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。-- 删除 DROP FUNCTION [IF EXISTS] function_name;-- 查看 SHOW FUNCTION STATUS LIKE &#x27;partten&#x27; SHOW CREATE FUNCTION function_name;-- 修改 ALTER FUNCTION function_name 函数选项--// 存储过程，自定义功能 ------------ 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建CREATE PROCEDURE sp_name (参数列表) 过程体参数列表：不同于函数的参数列表，需要指明参数类型IN，表示输入型OUT，表示输出型INOUT，表示混合型注意，没有返回值。 存储过程 12345678910111213141516/* 存储过程 */ ------------------存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：CALL 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出-- 语法CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END 用户和权限管理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* 用户和权限管理 */ -------------------- root密码重置1. 停止MySQL服务2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables3. use mysql;4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;5. FLUSH PRIVILEGES;用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES;-- 增加用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &#x27;user_name&#x27;@&#x27;192.168.1.1&#x27; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD(&#x27;密码&#x27;) -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD(&#x27;密码&#x27;) -- 为指定用户设置密码-- 删除用户DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO &#x27;pms&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;pms0817&#x27;;-- 查看权限SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限-- 权限层级-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限 表维护 12345678/* 表维护 */-- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 杂项 1234567891011121314/* 杂项 */ ------------------1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\&#x27;5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。6. SQL对大小写不敏感7. 清除已有语句：\\c","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhoumoon.github.io/tags/MySQL/"}]},{"title":"Mybatis-Plus 真好用","slug":"Java/Mybatis-Plus 真好用","date":"2017-09-10T23:12:22.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2017/09/11/Java/Mybatis-Plus 真好用/","link":"","permalink":"http://zhoumoon.github.io/2017/09/11/Java/Mybatis-Plus%20%E7%9C%9F%E5%A5%BD%E7%94%A8/","excerpt":"","text":"数据库准备 1CREATE TABLE tbl_user( user_id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;, user_name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;, user_age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;, PRIMARY KEY (user_id)) charset = utf8; MyBatis-Plus加持 工程搭建 （不赘述了） 依赖引入 1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;8.0.12&lt;/version&gt;&lt;/dependency&gt; 主要是 Mybatis Plus、Lombok（不知道Lombok干嘛的？可以看这里）、Druid连接池 等依赖。 MyBatis Plus配置 项目配置 123mybatis-plus: mapper-locations: classpath:/mapper/*Mapper.xml 新增 MyBatis Plus配置类 1234@Configuration@MapperScan(&quot;cn.codesheep.springbtmybatisplus.mapper&quot;)public class MyBatisConfig &#123;&#125; 看到没，几乎零配置啊，下面就可以写业务逻辑了 业务编写 实体类 12345678@Data@TableName(&quot;tbl_user&quot;)public class User &#123; @TableId(value = &quot;user_id&quot;) private Long userId; private String userName; private Integer userAge;&#125; Mapper类 1public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 这里啥接口方法也不用写，就可以实现增删改查了！ Service类 Service接口： 1234567public interface UserService extends IService&lt;User&gt; &#123; int insertUser( User user ); int updateUser( User user ); int deleteUser( User user ); User findUserByName( String userName ); IPage getUserPage( Page page, User user );&#125; Service实现： 12345678910111213141516171819202122232425262728@Service@AllArgsConstructorpublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; // 增 @Override public int insertUser(User user) &#123; return baseMapper.insert( user ); &#125; // 改 @Override public int updateUser(User user) &#123; return baseMapper.updateById( user ); &#125; // 删 @Override public int deleteUser(User user) &#123; return baseMapper.deleteById( user.getUserId() ); &#125; // 查 @Override public User findUserByName( String userName ) &#123; return baseMapper.getUserByName( userName ); &#125;&#125; Controller类 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(&quot;/user&quot;)public class UserContorller &#123; @Autowired private UserService userService; // 增 @PostMapping( value = &quot;/insert&quot;) public Object insert( @RequestBody User user ) &#123; return userService.insertUser( user ); &#125; // 改 @PostMapping( value = &quot;/update&quot;) public Object update( @RequestBody User user ) &#123; return userService.updateUser( user ); &#125; // 删 @PostMapping( value = &quot;/delete&quot;) public Object delete( @RequestBody User user ) &#123; return userService.deleteUser( user ); &#125; // 查 @GetMapping( value = &quot;/getUserByName&quot;) public Object getUserByName( @RequestParam String userName ) &#123; return userService.findUserByName( userName ); &#125;&#125; 通过以上几个简单的步骤，我们就实现了 tbl_user表的增删改查，传统 MyBatis的 XML文件一个都不需要写！ 最关心的分页问题 首先装配分页插件 1234@Beanpublic PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor();&#125; Mapper类 12345678public interface UserMapper extends BaseMapper&lt;User&gt; &#123; // 普通查询 User getUserByName( String userName ); // 分页查询 IPage&lt;List&lt;User&gt;&gt; getUsersPage( Page page, @Param(&quot;query&quot;) User user );&#125; Service类 12345678910111213141516@Service@AllArgsConstructorpublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; // 查：普通查 @Override public User findUserByName( String userName ) &#123; return baseMapper.getUserByName( userName ); &#125; // 分页查 @Override public IPage getUserPage(Page page, User user) &#123; return baseMapper.getUsersPage( page, user ); &#125;&#125; Controller类 1234@GetMapping( value = &quot;/page&quot;)public Object getUserPage( Page page, User user ) &#123; return userService.getUserPage( page, user );&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"}]},{"title":"MySQL高性能优化规范建议","slug":"DB/MySQL高性能优化规范建议","date":"2017-07-12T07:12:00.000Z","updated":"2023-08-01T01:45:09.865Z","comments":false,"path":"2017/07/12/DB/MySQL高性能优化规范建议/","link":"","permalink":"http://zhoumoon.github.io/2017/07/12/DB/MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/","excerpt":"","text":"数据库字段设计规范 1. 优先选择符合存储需要的最小的数据类型 2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据 3. 避免使用 ENUM 类型 4. 尽可能把所有列定义为 NOT NULL 5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间 6. 同财务相关的金额类数据必须使用 decimal 类型 索引设计规范 1. 限制每张表上的索引数量,建议单张表索引不超过 5 个 2. 禁止给表中的每一列都建立单独的索引 3. 每个 Innodb 表必须有个主键 4. 常见索引列建议 5.如何选择索引列的顺序 6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间） 7. 对于频繁的查询优先考虑使用覆盖索引 8.索引 SET 规范 数据库 SQL 开发规范 1. 建议使用预编译语句进行数据库操作 2. 避免数据类型的隐式转换 3. 充分利用表上已经存在的索引 4. 数据库设计时，应该要对以后扩展进行考虑 5. 程序连接不同的数据库使用不同的账号，禁止跨库查询 6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询 7. 禁止使用不含字段列表的 INSERT 语句 8. 避免使用子查询，可以把子查询优化为 join 操作 9. 避免使用 JOIN 关联太多的表 10. 减少同数据库的交互次数 11. 对应同一列进行 or 判断时，使用 in 代替 or 12. 禁止使用 order by rand() 进行随机排序 13. WHERE 从句中禁止对列进行函数转换和计算 14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION 15. 拆分复杂的大 SQL 为多个小 SQL 数据库操作行为规范 1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作 2. 对于大表使用 pt-online-schema-change 修改表结构 3. 禁止为程序使用的账号赋予 super 权限 4. 对于程序连接数据库账号,遵循权限最小原则 数据库命令规范 所有数据库对象名称必须使用小写字母并用下划线分割 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符 临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低） 数据库基本设计规范 1. 所有表必须使用 Innodb 存储引擎 没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。 Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。 2. 数据库和表的字符集统一使用 UTF8 兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。 3. 所有表和字段都需要添加注释 使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护 4. 尽量控制单表数据量的大小,建议控制在 500 万以内。 500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小 5. 谨慎使用 MySQL 分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表； 谨慎选择分区键，跨分区查询效率可能更低； 建议采用物理分表的方式管理大数据。 6.尽量做到冷热数据分离,减小表的宽度 MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。 减少磁盘 IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）； 更有效的利用缓存，避免读入无用的冷数据； 经常一起使用的列放到一个表中（避免更多的关联操作）。 7. 禁止在表中建立预留字段 预留字段的命名很难做到见名识义。 预留字段无法确认存储的数据类型，所以无法选择合适的类型。 对预留字段类型的修改，会对表进行锁定。 8. 禁止在数据库中存储图片,文件等大的二进制数据 通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。 通常存储于文件服务器，数据库只存储文件地址信息 9. 禁止在线上做数据库压力测试 10. 禁止从开发环境,测试环境直接连接生产环境数据库 数据库字段设计规范 1. 优先选择符合存储需要的最小的数据类型 原因： 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。 方法： a.将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据 MySQL 提供了两个方法来处理 ip 地址 inet_aton 把 ip 转为无符号整型 (4-8 位) inet_ntoa 把整型的 ip 转为地址 插入数据前，先用 inet_aton 把 ip 地址转为整型，可以节省空间，显示数据时，使用 inet_ntoa 把整型的 ip 地址转为地址显示即可。 b.对于非负型的数据 (如自增 ID,整型 IP) 来说,要优先使用无符号整型来存储 原因： 无符号相对于有符号可以多出一倍的存储空间 12SIGNED INT -2147483648~2147483647UNSIGNED INT 0~4294967295 VARCHAR(N) 中的 N 代表的是字符数，而不是字节数，使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。 2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据 a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中 MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。 如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。 2、TEXT 或 BLOB 类型只能使用前缀索引 因为MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的 3. 避免使用 ENUM 类型 修改 ENUM 值需要使用 ALTER 语句 ENUM 类型的 ORDER BY 操作效率低，需要额外操作 禁止使用数值作为 ENUM 的枚举值 4. 尽可能把所有列定义为 NOT NULL 原因： 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间 进行比较和计算时要对 NULL 值做特别的处理 5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07 TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高 超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储 经常会有人用字符串存储日期型的数据（不正确的做法） 缺点 1：无法用日期函数进行计算和比较 缺点 2：用字符串存储日期要占用更多的空间 6. 同财务相关的金额类数据必须使用 decimal 类型 非精准浮点：float,double 精准浮点：decimal Decimal 类型为精准浮点数，在计算时不会丢失精度 占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节 可用于存储比 bigint 更大的整型数据 索引设计规范 1. 限制每张表上的索引数量,建议单张表索引不超过 5 个 索引并不是越多越好！索引可以提高效率同样可以降低效率。 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。 因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。 2. 禁止给表中的每一列都建立单独的索引 5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。 3. 每个 Innodb 表必须有个主键 Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。 Innodb 是按照主键索引的顺序来组织表的 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长） 主键建议使用自增 ID 值 4. 常见索引列建议 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好 多表 join 的关联列 5.如何选择索引列的顺序 建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数） 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好） 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引） 6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间） 重复索引示例：primary key(id)、index(id)、unique index(id) 冗余索引示例：index(a,b,c)、index(a,b)、index(a) 7. 对于频繁的查询优先考虑使用覆盖索引 覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引 覆盖索引的好处： 避免 Innodb 表进行索引的二次查询: Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。 可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。 8.索引 SET 规范 尽量避免使用外键约束 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引 外键可用于保证数据的参照完整性，但建议在业务端实现 外键会影响父表和子表的写操作从而降低性能 数据库 SQL 开发规范 1. 建议使用预编译语句进行数据库操作 预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。 只传参数，比传递 SQL 语句更高效。 相同语句可以一次解析，多次使用，提高处理效率。 2. 避免数据类型的隐式转换 隐式转换会导致索引失效如: 1select name,phone from customer where id = &#x27;111&#x27;; 3. 充分利用表上已经存在的索引 避免使用双%号的查询条件。如：a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的） 一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。 在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。 4. 数据库设计时，应该要对以后扩展进行考虑 5. 程序连接不同的数据库使用不同的账号，禁止跨库查询 为数据库迁移和分库分表留出余地 降低业务耦合度 避免权限过大而产生的安全风险 6. 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询 原因： 消耗更多的 CPU 和 IO 以网络带宽资源 无法使用覆盖索引 可减少表结构变更带来的影响 7. 禁止使用不含字段列表的 INSERT 语句 如： 1insert into values (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); 应使用： 1insert into t(c1,c2,c3) values (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); 8. 避免使用子查询，可以把子查询优化为 join 操作 通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。 子查询性能差的原因： 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。 9. 避免使用 JOIN 关联太多的表 对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。 在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。 如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。 10. 减少同数据库的交互次数 数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。 11. 对应同一列进行 or 判断时，使用 in 代替 or in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。 12. 禁止使用 order by rand() 进行随机排序 order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。 13. WHERE 从句中禁止对列进行函数转换和计算 对列进行函数转换或计算时会导致无法使用索引 不推荐： 1where date(create_time)=&#x27;20190101&#x27; 推荐： 1where create_time &gt;= &#x27;20190101&#x27; and create_time &lt; &#x27;20190102&#x27; 14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作 UNION ALL 不会再对结果集进行去重操作 15. 拆分复杂的大 SQL 为多个小 SQL 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL MySQL 中，一个 SQL 只能使用一个 CPU 进行计算 SQL 拆分后可以通过并行执行来提高处理效率 数据库操作行为规范 1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作 大批量操作可能会造成严重的主从延迟 主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况 binlog 日志为 row 格式时会产生大量的日志 大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因 避免产生大事务操作 大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。 特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批 2. 对于大表使用 pt-online-schema-change 修改表结构 避免大表修改产生的主从延迟 避免在对表字段进行修改时进行锁表 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。 pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。 3. 禁止为程序使用的账号赋予 super 权限 当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接 super 权限只能留给 DBA 处理问题的账号使用 4. 对于程序连接数据库账号,遵循权限最小原则 程序使用数据库账号只能在一个 DB 下使用，不准跨库 程序使用的账号原则上不准有 drop 权限","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://zhoumoon.github.io/tags/MySQL/"}]},{"title":"Linux 防火墙","slug":"Linux/Linux_防火墙","date":"2016-09-23T02:22:01.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2016/09/23/Linux/Linux_防火墙/","link":"","permalink":"http://zhoumoon.github.io/2016/09/23/Linux/Linux_%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"","text":"Linux 防火墙 1234567891011121314151617# 安装防火墙yum install firewalld# 查看开放的端口firewalld-cmd --list-all# 关闭防火墙systemctl stop firewalld# 禁用防火墙systemctl disable firewalld# 开启防火墙firewall-cmd --zone=public --add-port=3306/tcp --permanent# 刷新配置firewall-cmd --reload","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"VMWare Linux 磁盘占用无限增加问题","slug":"Linux/VMWare_Linux_磁盘占用无限增加问题","date":"2016-09-23T02:18:19.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2016/09/23/Linux/VMWare_Linux_磁盘占用无限增加问题/","link":"","permalink":"http://zhoumoon.github.io/2016/09/23/Linux/VMWare_Linux_%E7%A3%81%E7%9B%98%E5%8D%A0%E7%94%A8%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0%E9%97%AE%E9%A2%98/","excerpt":"","text":"VMWare Linux 磁盘占用无限增加问题 VMWare Linux 磁盘占用无限增加问题 安装好VmWar-Tool 执行压缩","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"Linux 安装 Tomcat 问题","slug":"Linux/Linux_安装_Tomcat_问题","date":"2016-09-23T01:15:21.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2016/09/23/Linux/Linux_安装_Tomcat_问题/","link":"","permalink":"http://zhoumoon.github.io/2016/09/23/Linux/Linux_%E5%AE%89%E8%A3%85_Tomcat_%E9%97%AE%E9%A2%98/","excerpt":"","text":"Linux 安装 Tomcat 问题 12345678910111213141516171819202122232425262728# (1)上传Tomcat的安装包的服务器# (2)解压缩安装包到指定multar -xvf apache-tomcat-8.5.15.tar.gz -C /usr/local/# (3)进入到解压缩目录,修改目录名称cd /usr/local/mv apache-tomcat-8.5.15/ tomcat# (4)进入到tomcat的命令目录cd tomcat/bin# 启动命令: ./startup.sh# (5)配置tomcat的管理控制台界面# 第一个地方:修改 tomcat/conf/tomcat-users.xml# 增加:&lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;user username=&quot;tomcat&quot; password=&quot;123&quot; roles=&quot;manager-gui&quot;/&gt;#第二个地方:# tomcat/webapps/manager/META-INF/context.xml# 注释掉 &lt;!-- &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; --&gt;# (6)重启tomcat# tomcat/bin./shutdown.sh //关闭tomcat./startup.sh //启动tomcat 设置用户名密码 启动tomcat后浏览器http://localhost:8080能够访问成功，但是点击Manager App一直报403，通过百度查找原因，首先在tomcat-users.xml 12&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;s3cret&quot; roles=&quot;manager-gui&quot;/&gt; 设置访问权限 之后重启tomcat还是不能访问，还是403，继续百度。试了n种方法都不行，最后在一个国外的网站找到了答案。 https://stackoverflow.com/questions/38551166/403-access-denied-on-tomcat-8-manager-app-without-prompting-for-user-password 总结如下: 还需要修改apache-tomcat-8.5.5\\webapps\\manager\\META-INF\\context.xml中的配置。 取消地址限制; 注释掉这段代码即可，这样就可以用用户名和密码访问Manager App了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"Linux 安装 Tomcat 问题","slug":"Linux/Linux开机自启动tomcat","date":"2016-09-23T01:15:21.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2016/09/23/Linux/Linux开机自启动tomcat/","link":"","permalink":"http://zhoumoon.github.io/2016/09/23/Linux/Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8tomcat/","excerpt":"","text":"Linux开机自启动tomcat Linux开机自启动tomcat 操作环境 服务器centos7.3 配置开机自启动tomcat 众所周知，在Linux中设置开机自启动的服务，需要在/etc/rcX.d下挂载。除此之外还需要在/etc/init.d下些启动脚本。其实很简单，先export出所需要的环境变量，例如JAVA_HOME，JRE_HOME, CATALINA_HOME, CATALINA_BASE什么的，然后再直接调用$CATALINA_HOME/bin/startup.sh就能成功启动。 1，我们在/etc/init.d下新建一个文件tomcat（需要在root权限下操作） 1vim /etc/init.d/tomcat 写下如下代码，tomcat自启动脚本： tomcat.hxd 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/sh# chkconfig: 345 99 10 # description: Auto-starts tomcat # /etc/init.d/tomcatd # Tomcat auto-start # Source function library. . /etc/init.d/functions # source networking configuration. . /etc/sysconfig/network RETVAL=0 export JAVA_HOME=/usr/local/jdk export CATALINA_HOME=/usr/local/tomcat8.5 export CATALINA_BASE=/usr/local/tomcat8.5start() &#123; if [ -f $CATALINA_HOME/bin/startup.sh ]; then echo $&quot;Starting Tomcat&quot; $CATALINA_HOME/bin/startup.sh RETVAL=$? echo &quot; OK&quot; return $RETVAL fi &#125; stop() &#123; if [ -f $CATALINA_HOME/bin/shutdown.sh ]; then echo $&quot;Stopping Tomcat&quot; $CATALINA_HOME/bin/shutdown.sh RETVAL=$? sleep 1 ps -fwwu tomcat | grep apache-tomcat|grep -v grep | grep -v PID | awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9 echo &quot; OK&quot; # [ $RETVAL -eq 0 ] &amp;&amp; rm -f /var/lock/... return $RETVAL fi &#125; case &quot;$1&quot; in start) start ;; stop) stop ;; restart) echo $&quot;Restaring Tomcat&quot; $0 stop sleep 1 $0 start ;; *) echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot; exit 1 ;; esac exit $RETVAL 这里特别提醒注意这一句ps -fwwu root | grep tomcat|grep -v grep | grep -v PID | awk '&#123;print $2&#125;'|xargs kill -9，熟悉Linux命令的人应该都清楚这句话的意义，这里就简单说下前半部分，查询root用户下tomcat的进程PID，个人根据实际情况修改。 2，保存退出之后，给其增加可执行权限 1chmod +x /etc/init.d/tomcat 3，设定开机启动服务 1chkconfig tomcat on 4，验证 执行reboot重启之后就会发现，Tomcat已经成功运行 1reboot 添加这个脚本之后我们启动，停止，重启tomcat可以直接用命令 123service tomcat startservice tomcat stopservice tomcat restart 问题1 1，CentOS7 下安装 Tomcat8 并且解决启动速度巨慢的问题 解决： 增大/dev/random的熵池，问题的原因是由于熵池不够大，所以增大它是最彻底的方法。我们可以通过软件的方法实现，下面是软件的安装和配置流程。 1234安装熵服务yum install rng-tools启动熵服务systemctl start rngd 如果你的 CPU 不支持 DRNG 特性或者像我一样使用虚拟机，可以使用/dev/unrandom来模拟。 123cp /usr/lib/systemd/system/rngd.service /etc/systemd/system vim /etc/systemd/system/rngd.service #以下是编辑内容 ExecStart=/sbin/rngd -f -r /dev/urandom 重新载入服务 12systemctl daemon-reloadsystemctl restart rngd 经过上面的修改，我们再观察 /proc/sys/kernel/random/entropy_avail 基本上在 3000 左右。这个时候重新启动 Tomcat，发现启动时间正常。 问题2: 为应用程序创建初始化脚本后，运行服务会导致以下错误： env: /etc/init.d/your_init_script: No such file or directory 诊断 环境 unix系统上可能会出现此问题 诊断步骤 运行以下命令： 检查输出， 原因 回车符已插入您的初始化脚本中。 解析 从初始化脚本中删除回车符。 sed -i -e ‘s/\\r//g’ /etc/init.d/your_init_script 这将删除回车符，之后您可以成功启动服务","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]},{"title":"Linux 安装JDK","slug":"Linux/Linux_安装JDK","date":"2016-09-23T00:13:11.000Z","updated":"2023-08-01T01:45:09.868Z","comments":false,"path":"2016/09/23/Linux/Linux_安装JDK/","link":"","permalink":"http://zhoumoon.github.io/2016/09/23/Linux/Linux_%E5%AE%89%E8%A3%85JDK/","excerpt":"","text":"Linux 安装JDK 1、上传jdk的安装包 or 下载 华为镜像地址 2、解压缩jdk安装包 1tar -xvf jdk.tar.gz -C /usr/local/ 3、进入jdk解压缩后的目录，修改解压缩目录名称 123cd /usr/local# 改名mv jdk1.8.0_131 jdk 4、修改环境变量配置文件 12345vi /etc/profileexport JAVA_HOME=/usr/local/jdkexport CLASSPATH=$JAVA_HOME/lib:.export PATH=$JAVA_HOME/bin:$PATH 5、让环境变量立刻生效 1source /etc/profile 6、测试 1java -version","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"}]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhoumoon.github.io/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://zhoumoon.github.io/tags/Docker/"},{"name":"Java","slug":"Java","permalink":"http://zhoumoon.github.io/tags/Java/"},{"name":"Windows","slug":"Windows","permalink":"http://zhoumoon.github.io/tags/Windows/"},{"name":"IDE","slug":"IDE","permalink":"http://zhoumoon.github.io/tags/IDE/"},{"name":"理财","slug":"理财","permalink":"http://zhoumoon.github.io/tags/%E7%90%86%E8%B4%A2/"},{"name":"Work","slug":"Work","permalink":"http://zhoumoon.github.io/tags/Work/"},{"name":"Git","slug":"Git","permalink":"http://zhoumoon.github.io/tags/Git/"},{"name":"Vim","slug":"Vim","permalink":"http://zhoumoon.github.io/tags/Vim/"},{"name":"Http","slug":"Http","permalink":"http://zhoumoon.github.io/tags/Http/"},{"name":"Oracle","slug":"Oracle","permalink":"http://zhoumoon.github.io/tags/Oracle/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhoumoon.github.io/tags/MySQL/"}]}